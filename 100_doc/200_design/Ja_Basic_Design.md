# 基本設計書
# Tributary - Solana報酬配布システム

**更新日**: 2025-09-18
**更新者**: akameGusya

## 概要
TributaryシステムのTypeScript/Node.js実装における基本設計思想と設計判断の根拠を定義する。アーキテクチャの設計意図、コンポーネント間の関係性、システム全体の設計原則を記述し、実装フェーズにおける設計指針を提供する。

## 設計方針
本設計書では、システムアーキテクチャの設計意図、技術選択の根拠、および考慮すべき要件を体系的に整理する。設計判断の背景となる制約条件、品質要件、将来展望を明示し、実装および保守における一貫性のある判断基準を確立する。

## 1. アーキテクチャ設計

### 1.1 設計哲学と基本原則

#### 1.1.1 レイヤードアーキテクチャの採用
4層のレイヤードアーキテクチャ（Presentation、Application、Service、Infrastructure）を基本構造として採用する。

**採用根拠**:
- **責務の明確化**: 各層の責任範囲を明確に定義し、変更影響の局所化を実現
- **テスト戦略**: 層間の独立性により単体テストおよび結合テストの効率化を図る
- **技術進化への対応**: 外部技術（ブロックチェーン、UI技術等）の変更に対する耐性を確保
- **開発生産性**: 層別の並行開発により開発リードタイムを短縮

#### 1.1.2 依存性注入パターンの採用
コンストラクタインジェクションによる依存性注入を全コンポーネントに適用する。

**採用根拠**:
- **疎結合の実現**: インターフェースベースの依存関係により実装変更時の影響を最小化
- **テスト品質の向上**: モックオブジェクトの注入により包括的な単体テストを実現
- **設定管理の統一**: 依存関係の解決をアプリケーション起動時に一元化し保守性を向上

### 1.2 技術選択の設計判断

#### 1.2.1 TypeScript/Node.js技術スタックの選択
TypeScript/Node.jsを主要開発言語として採用する。

**選択根拠**:
- **型安全性の確保**: 静的型チェックによる実行時エラーの事前検出
- **開発効率の最大化**: 豊富なライブラリエコシステムと成熟した開発ツールチェーンの活用
- **Solana統合の最適化**: 公式SDK（@solana/web3.js）との自然な統合による開発リスクの軽減
- **技術スタック統一**: 将来的なフロントエンド開発との技術基盤共通化

#### 1.2.2 CLI主導アプローチの採用
コマンドラインインターフェースを第一次開発対象として位置付ける。

**採用根拠**:
- **運用自動化への適応**: CI/CDパイプラインおよび運用スクリプトとの統合容易性
- **開発速度の最適化**: GUI開発と比較した機能提供までのリードタイム短縮
- **操作の再現性**: スクリプト化による処理の標準化と再実行可能性の確保
- **問題解決効率**: コマンドライン操作による障害調査および復旧作業の迅速化

#### 1.2.3 依存ライブラリのバージョン選定方針

**バージョン選定基準**:
システムの安定性と保守性を確保するため、以下の基準に基づいて依存ライブラリのバージョンを選定する。

**メジャーバージョン選定**:
- **安定性重視**: リリースから6ヶ月以上経過し、重大な既知問題が解決されたバージョンを選択
- **LTS優先**: Long Term Support版が提供される場合は、LTS版を優先的に採用
- **セキュリティ対応**: 最新のセキュリティ更新が適用されているバージョンを選択

**Solana関連ライブラリ**:
- **@solana/web3.js**: Solana公式ライブラリの最新安定版を採用
- **@solana/spl-token**: SPLトークン操作の標準ライブラリ安定版を採用
- **互換性検証**: 各ライブラリ間のバージョン互換性を事前に検証し、動作確認済みの組み合わせを採用

**開発ツールチェーン**:
- **TypeScript**: 安定版最新を採用し、新機能の段階的導入を図る
- **Node.js**: 現行LTS版を基準とし、実行環境の統一を図る
- **テストフレームワーク**: Jest安定版を採用し、広範囲なコミュニティサポートを活用

## 2. コンポーネント設計思想

### 2.1 Wallet Collector の設計戦略

#### 2.1.1 コンポーネント設計目的
Solanaブロックチェーン上のトークン保有者情報を効率的に収集し、配布処理のための対象者リストを生成する。

**設計原則**:
- **単一責任の徹底**: ウォレット情報収集機能に特化し、配布ロジックとの責務分離を実現
- **性能要件の充足**: 大規模データセット処理に対応するスケーラブルなアルゴリズム設計
- **リソース最適化**: 重複処理の排除およびキャッシュ機構によるシステムリソース効率化

#### 2.1.2 処理方式の設計
**バッチ処理方式の採用**:
大量ウォレット処理（1000+件）において実用的な処理時間を達成するため、バッチ単位での並行処理を採用する。これにより外部RPCエンドポイントへの負荷分散と全体処理時間の最適化を実現する。

**段階的フィルタリング方式**:
データ処理の初期段階で条件に適合しない要素を除外することにより、後続処理におけるメモリ使用量削減と処理速度向上を図る。

### 2.2 Distribution Engine の設計戦略

#### 2.2.1 コンポーネント設計目的
公平かつ正確なトークン配布処理の実行および大規模配布における処理信頼性の確保を目的とする。

**設計要件**:
- **処理完全性**: 部分失敗に対する状態管理および復旧機能の実装
- **監査対応**: 全配布処理の完全な記録および追跡可能性の確保
- **処理規模**: 1000+受信者への効率的配布処理の実現

#### 2.2.2 配布アルゴリズム設計
**比例配分方式の採用**:
数学的公平性を担保するため、基準トークン保有量に完全比例した配布量算出を実装する。浮動小数点演算の精度問題を回避し、整数ベース計算により配布総額の厳密な制御を実現する。

**バッチ実行アーキテクチャ**:
Solanaブロックチェーンの高スループット特性を活用したバッチ処理により、個別トランザクション失敗の全体への影響を防止する。同時に処理進捗のリアルタイム監視機能を提供する。

### 2.3 Token Service の抽象化戦略

#### 2.3.1 抽象化の設計意図
**設計目的**: Solanaブロックチェーンの技術的複雑性をアプリケーション層から隠蔽し、シンプルで一貫性のあるAPIを提供。

**抽象化レベルの設計判断**:
- **適切な抽象度**: 過度に抽象化せず、Solana固有の特徴を活かした設計
- **型安全性**: TypeScriptの型システムを活用したコンパイル時エラー防止
- **エラー処理統一**: ブロックチェーン固有のエラーの正規化

#### 2.3.2 ネットワーク管理の設計
**マルチネットワーク対応**:
- **開発フロー支援**: devnet → testnet → mainnet への段階的移行
- **設定の一元化**: ネットワーク切り替えの簡素化
- **環境分離**: 各環境での独立した動作保証

## 3. データ設計思想

### 3.1 データモデルの設計原則
**設計原則**:
- **完全性**: 監査要件を満たす包括的な情報記録
- **正規化**: データの一貫性と冗長性の排除
- **拡張性**: 将来的な機能追加に対応可能な構造

### 3.2 永続化戦略
**ファイルベース永続化の選択理由**:
- **シンプリシティ**: 外部データベース依存の回避
- **ポータビリティ**: 環境に依存しない実行可能性
- **セキュリティ**: ローカル制御によるデータ保護

## 4. セキュリティ設計原則

### 4.1 秘密鍵管理の戦略
**設計原則**:
- **最小権限**: 必要最小限の権限での実行
- **暗号化保存**: 業界標準の暗号化による秘密鍵保護
- **メモリ管理**: 使用後の即座なメモリクリア

### 4.2 監査証跡の設計
**監査要件対応**:
- **完全なログ記録**: 全ての重要操作の記録
- **改ざん検証**: ログの整合性確認機能
- **長期保存**: 法的要件を満たす保存期間の設定

## 5. パフォーマンス設計戦略

### 5.1 スケーラビリティの考慮事項
**大規模配布への対応**:
- **並行処理**: 独立処理の並行実行による時間短縮
- **メモリ効率**: ストリーミング処理による大量データ対応
- **キャッシュ戦略**: 頻繁アクセスデータの効率的な管理

### 5.2 Solanaネットワークの特性活用
**高スループットの活用**:
- **バッチ最適化**: Solanaの65,000 TPS能力の効果的利用
- **低レイテンシ**: 400ms以下の処理時間達成
- **コスト効率**: トランザクション費用の最小化

## 6. エラー処理とレジリエンス

### 6.1 障害対応の設計思想
**レジリエンス戦略**:
- **部分失敗対応**: 全体停止を避ける段階的処理
- **自動復旧**: 一時的障害からの自動回復機能
- **詳細診断**: 問題特定と対策提案の自動化

### 6.2 ユーザビリティとエラー通知
**エラー体験の設計**:
- **明確なメッセージ**: 技術者でない利用者にも理解可能な説明
- **対処法提示**: エラー発生時の具体的な解決策提示
- **段階的詳細**: 基本情報から詳細まで段階的な情報提供

## 7. 拡張性と将来展望

### 7.1 将来機能への対応設計
**拡張ポイント**:
- **マルチチェーン対応**: アーキテクチャレベルでの他チェーン対応準備
- **API化**: REST APIエンドポイントの追加対応
- **WebUI統合**: Webダッシュボードとの連携設計

### 7.2 コミュニティ開発への配慮
**オープンソース戦略**:
- **コントリビューション容易性**: 明確な責務分離による参加障壁の低減
- **ドキュメント充実**: 設計意図の明文化による理解促進
- **テスト容易性**: 新機能追加時の回帰テスト効率化

## 8. 運用設計の考慮事項

### 8.1 監視とアラート
**運用監視戦略**:
- **健全性監視**: システム稼働状況の継続的監視
- **パフォーマンス監視**: 処理性能の劣化検知
- **セキュリティ監視**: 異常アクセスパターンの検出

### 8.2 メンテナンス性の設計
**保守効率の向上**:
- **設定の外部化**: 実行時設定変更による柔軟性
- **ログの構造化**: 機械処理可能なログフォーマット
- **デバッグ支援**: 問題特定を支援する詳細情報の提供

