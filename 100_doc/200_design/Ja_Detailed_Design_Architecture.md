# アーキテクチャ詳細設計書
# Tributary - Solana報酬配布システム

**更新日**: 2025-09-18
**更新者**: akameGusya

## 概要
本文書は、Tributaryシステムの4層アーキテクチャの詳細設計を定義する。各層の具体的な責務、インターフェース仕様、および層間連携の実装方針を記述する。

## 1. 全体アーキテクチャ詳細

### 1.1 層構造詳細定義

#### 1.1.1 Presentation Layer（表示層）
**責務範囲**:
- CLI コマンドの解析および実行制御
- ユーザー入力の検証および正規化
- 実行結果の整形および出力制御
- エラーメッセージの生成および表示

**内部構造**:
- **CommandParser**: コマンドライン引数の解析
- **CommandExecutor**: 各コマンドの実行制御
- **OutputFormatter**: 結果出力の整形
- **ErrorHandler**: エラー処理および表示

**制約事項**:
- ビジネスロジックを含まない
- 下位層への直接的なデータ変更指示を行わない
- ユーザーインターフェースのみに関心を持つ

#### 1.1.2 Application Layer（アプリケーション層）
**責務範囲**:
- ビジネスプロセスの制御および調整
- 複数サービス間のワークフロー管理
- トランザクション境界の制御
- ビジネスルールの適用

**内部構造**:
- **WalletCollectorService**: ウォレット収集処理の制御
- **DistributionService**: 配布処理の制御
- **ConfigurationService**: 設定管理処理の制御
- **WorkflowManager**: 複合処理の調整

**制約事項**:
- UI固有の処理を含まない
- 永続化の詳細を知らない
- 外部システムの詳細を知らない

#### 1.1.3 Service Layer（サービス層）
**責務範囲**:
- 共通機能の提供
- 横断的関心事の処理
- ユーティリティ機能の実装
- インフラストラクチャへのアクセス制御

**内部構造**:
- **TokenService**: Solanaトークン操作の抽象化
- **CacheService**: キャッシュ管理機能
- **LoggerService**: ログ処理機能
- **ConfigManager**: 設定ファイル管理

**制約事項**:
- ビジネスロジックを含まない
- プレゼンテーション固有の処理を含まない
- ステートレスな設計を維持

#### 1.1.4 Infrastructure Layer（インフラ層）
**責務範囲**:
- 外部システムとの通信処理
- データの永続化処理
- システムリソースへのアクセス
- 技術的詳細の実装

**内部構造**:
- **SolanaRpcClient**: Solanaネットワーク通信
- **FileRepository**: ファイルシステムアクセス
- **NetworkManager**: ネットワーク通信管理
- **CryptoProvider**: 暗号化処理

**制約事項**:
- 上位層のビジネスロジックを知らない
- 技術的詳細のみに関心を持つ
- 外部システムの変更を上位層から隔離

### 1.2 層間インターフェース仕様

#### 1.2.1 Presentation → Application 間インターフェース
**データフロー**:
```
User Input → CommandParser → CommandExecutor → ApplicationService → Result → OutputFormatter → User Output
```

**インターフェース原則**:
- アプリケーションサービスはコマンド実行の結果のみを返す
- エラー情報は構造化された例外として伝達
- プレゼンテーション層は結果の解釈を担当

**データ形式**:
- 入力: プリミティブ型またはプレーンオブジェクト
- 出力: 構造化された結果オブジェクトまたは例外

#### 1.2.2 Application → Service 間インターフェース
**データフロー**:
```
ApplicationService → ServiceInterface → ConcreteService → Infrastructure → Result
```

**インターフェース原則**:
- サービス層は機能単位の操作を提供
- アプリケーション層は複数サービスを組み合わせてワークフローを構成
- 非同期処理はPromiseベースで統一

**依存性注入**:
- アプリケーションサービスはサービス層のインターフェースに依存
- 具象実装はDIコンテナで注入
- テスト時はモックサービスを注入

#### 1.2.3 Service → Infrastructure 間インターフェース
**データフロー**:
```
Service → InfrastructureInterface → ConcreteInfrastructure → ExternalSystem
```

**インターフェース原則**:
- インフラストラクチャ層は技術的操作のみを提供
- サービス層はビジネス的意味を付与
- エラー処理はサービス層で業務的エラーに変換

**技術的考慮事項**:
- 接続プール管理
- リトライ機構
- タイムアウト制御
- セキュリティ認証

## 2. 依存性注入アーキテクチャ

### 2.1 DIコンテナ設計

#### 2.1.1 コンテナ構造
**階層化されたコンテナ**:
- **ApplicationContainer**: アプリケーションサービスの管理
- **ServiceContainer**: 共通サービスの管理
- **InfrastructureContainer**: インフラコンポーネントの管理

**ライフサイクル管理**:
- **Singleton**: ステートレスなサービス（Logger、Config等）
- **Transient**: ステートフルなサービス（特定処理用オブジェクト）
- **Scoped**: リクエスト単位のライフサイクル

#### 2.1.2 依存関係解決戦略
**解決順序**:
1. Infrastructure Layer の初期化
2. Service Layer の初期化
3. Application Layer の初期化
4. Presentation Layer の初期化

**循環依存の回避**:
- イベント駆動による疎結合
- インターフェース分離原則の適用
- Factory パターンの活用

### 2.2 設定管理アーキテクチャ

#### 2.2.1 設定の階層化
**設定レベル**:
- **システム設定**: アプリケーション全体の基本設定
- **環境設定**: 実行環境固有の設定
- **ユーザー設定**: プロジェクト固有の設定
- **実行時設定**: コマンド実行時のパラメータ

**優先順位**:
実行時設定 > ユーザー設定 > 環境設定 > システム設定

#### 2.2.2 設定検証機能
**検証レベル**:
- **構文検証**: 設定ファイルの形式確認
- **意味検証**: 設定値の妥当性確認
- **整合性検証**: 設定間の依存関係確認
- **環境検証**: 実行環境との整合性確認

## 3. エラー処理アーキテクチャ

### 3.1 エラー分類体系

#### 3.1.1 エラーカテゴリ
**システムエラー**:
- ネットワーク接続エラー
- ファイルシステムエラー
- メモリ不足エラー

**ビジネスエラー**:
- 入力データ不正
- ビジネスルール違反
- 処理条件不適合

**外部システムエラー**:
- Solana RPC エラー
- 第三者 API エラー
- タイムアウトエラー

#### 3.1.2 エラー処理戦略
**回復可能エラー**:
- 自動リトライ機構
- フォールバック処理
- 代替手段の実行

**回復不可能エラー**:
- 適切なクリーンアップ処理
- 詳細なエラー情報の記録
- ユーザーへの明確な通知

### 3.2 例外伝播方針

#### 3.2.1 層間例外処理
**Infrastructure Layer**:
- 技術的例外をビジネス中立な例外に変換
- 詳細な技術情報をログに記録
- 上位層には抽象化された例外を通知

**Service Layer**:
- ビジネス的意味を持つ例外に変換
- 業務的なエラーハンドリングの実行
- アプリケーション層にビジネス例外を通知

**Application Layer**:
- ワークフロー全体の整合性確保
- 部分失敗時の補償処理
- プレゼンテーション層に結果を通知

**Presentation Layer**:
- ユーザーフレンドリーなエラーメッセージ生成
- 適切なログレベルでの記録
- 復旧手順の提示

## 4. 非同期処理アーキテクチャ

### 4.1 非同期処理方針

#### 4.1.1 非同期パターン
**Promise ベース処理**:
- 全ての非同期処理をPromiseで統一
- async/await による可読性向上
- エラーハンドリングの一貫性確保

**並行処理制御**:
- Promise.all による並行実行
- Promise.allSettled による部分失敗対応
- セマフォによる同時実行数制御

#### 4.1.2 リソース管理
**接続プール**:
- Solana RPC 接続の効率的管理
- 接続数の上限制御
- 使用済み接続の適切な解放

**メモリ管理**:
- 大量データ処理時のストリーミング
- 不要オブジェクトの適切な解放
- ガベージコレクション負荷の最小化

## 5. 拡張性アーキテクチャ

### 5.1 プラグインアーキテクチャ

#### 5.1.1 拡張ポイント
**新規コマンド追加**:
- CommandPlugin インターフェースの実装
- 動的コマンド登録機構
- ヘルプシステムとの統合

**新規ブロックチェーン対応**:
- BlockchainProvider インターフェースの実装
- ネットワーク設定の抽象化
- トークン仕様の差異吸収

#### 5.1.2 プラグイン管理
**プラグインライフサイクル**:
- 動的ロード・アンロード
- 依存関係解決
- バージョン互換性確認

**セキュリティ考慮**:
- プラグインの署名検証
- 実行権限の制限
- サンドボックス実行環境

### 5.2 API 拡張アーキテクチャ

#### 5.2.1 REST API 対応準備
**アーキテクチャ拡張**:
- Express.js レイヤーの追加
- 既存アプリケーション層の再利用
- 認証・認可機構の統合

**データ形式統一**:
- JSON スキーマの定義
- CLI 出力との整合性確保
- バージョニング戦略

#### 5.2.2 WebSocket 対応準備
**リアルタイム通信**:
- 配布進捗のリアルタイム通知
- 接続管理機構
- スケーラビリティ考慮

## 6. テスト対応アーキテクチャ

### 6.1 テスタビリティ設計

#### 6.1.1 依存性分離
**モック対応**:
- 全外部依存のインターフェース化
- テスト用モック実装の提供
- テストデータの管理機構

**テスト分離**:
- 単体テスト用の軽量コンテナ
- 統合テスト用の完全環境
- E2Eテスト用のテストネット活用

#### 6.1.2 テストデータ管理
**テストケース設計**:
- 正常系シナリオ
- 異常系シナリオ
- 境界値テスト
- パフォーマンステスト

**テスト環境管理**:
- 再現可能なテスト環境
- テストデータのセットアップ・ティアダウン
- 並行テスト実行対応