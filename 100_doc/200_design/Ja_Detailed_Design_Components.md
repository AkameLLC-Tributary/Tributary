# コンポーネント詳細設計書
# Tributary - Solana報酬配布システム

**更新日**: 2025-09-18
**更新者**: akameGusya

## 概要
本文書は、Tributaryシステムの各コンポーネントの詳細設計を定義する。クラス構造、メソッド仕様、状態管理、およびコンポーネント間の相互作用を記述する。

## 1. Presentation Layer コンポーネント

### 1.1 TributaryCLI（メインエントリポイント）

#### 1.1.1 クラス責務
**主要責務**:
- アプリケーション初期化と終了処理
- コマンドライン引数の解析
- グローバル設定の管理
- エラーハンドリングの統括

**設計原則**:
- ビジネスロジックを含まない
- 依存性注入コンテナの初期化
- アプリケーション全体のライフサイクル管理

#### 1.1.2 主要メソッド仕様

**initialize(): Promise<void>**
- 目的: アプリケーション初期化処理
- 処理: DIコンテナ設定、設定ファイル読み込み、ログ初期化
- 例外: InitializationError（初期化失敗時）
- 前提条件: なし
- 事後条件: 全サービスが利用可能状態

**parseArguments(argv: string[]): CommandContext**
- 目的: コマンドライン引数の解析と検証
- 入力: プロセス引数配列
- 出力: 解析済みコマンドコンテキスト
- 例外: ArgumentParseError（引数不正時）
- 検証: 必須パラメータ、型チェック、値範囲

**executeCommand(context: CommandContext): Promise<void>**
- 目的: 解析済みコマンドの実行制御
- 処理: 適切なCommandExecutorへの委譲
- エラー処理: ビジネス例外をユーザーフレンドリーなメッセージに変換
- ログ: 実行開始・終了・例外のログ記録

#### 1.1.3 状態管理
**アプリケーション状態**:
- **INITIALIZING**: 初期化中
- **READY**: コマンド実行可能
- **EXECUTING**: コマンド実行中
- **TERMINATING**: 終了処理中
- **ERROR**: エラー状態

**状態遷移制御**:
- 不正な状態遷移の防止
- 状態変更時のイベント通知
- 終了時のリソースクリーンアップ

### 1.2 CommandExecutor（コマンド実行制御）

#### 1.2.1 設計パターン
**Command パターンの適用**:
- 各コマンドを独立したオブジェクトとして実装
- 共通インターフェース（ICommand）による統一
- 動的なコマンド追加・削除への対応

**責任連鎖パターンの活用**:
- コマンド前処理・後処理の統一
- ミドルウェア機能の実装
- 横断的関心事の処理

#### 1.2.2 コマンド種別と仕様

**InitCommand（初期化コマンド）**
- 目的: プロジェクト設定の初期化
- 入力検証: プロジェクト名、ネットワーク指定の妥当性
- 処理内容: 設定ファイル作成、ディレクトリ構造構築
- 出力: 初期化完了メッセージ、設定内容確認

**CollectCommand（ウォレット収集コマンド）**
- 目的: トークン保有者情報の収集
- 前提条件: プロジェクト初期化済み
- 処理内容: WalletCollectorService の実行制御
- 進捗表示: リアルタイム進捗バー、統計情報表示
- 結果出力: 収集件数、処理時間、保存先情報

**DistributeCommand（配布実行コマンド）**
- 目的: トークン配布の実行
- サブコマンド: execute（手動実行）、auto（自動設定）
- 安全確認: 実行前の確認プロンプト（本番時）
- 処理制御: DistributionService の実行監視
- 結果報告: 成功・失敗件数、トランザクション詳細

**ConfigCommand（設定管理コマンド）**
- 目的: 設定情報の表示・操作
- サブコマンド: show（表示）、export（エクスポート）
- 表示形式: 階層化された設定情報の整理表示
- セキュリティ: 機密情報のマスク表示

#### 1.2.3 共通処理機能

**前処理（Pre-processing）**:
- 設定ファイル存在確認
- 必要な権限チェック
- ネットワーク接続確認
- 実行環境検証

**後処理（Post-processing）**:
- 実行結果のログ記録
- 統計情報の更新
- 一時ファイルのクリーンアップ
- 通知処理（設定により）

### 1.3 OutputFormatter（出力整形）

#### 1.3.1 出力形式設計

**テーブル形式出力**:
- 列幅の自動調整
- ヘッダー・境界線の統一
- 大量データの改ページ処理
- 色分け表示（ターミナル対応時）

**JSON形式出力**:
- 構造化データの出力
- 外部ツール連携対応
- スキーマ一貫性の保証
- 圧縮・整形オプション

**プログレス表示**:
- 進捗バーの表示
- 推定残り時間の算出
- 現在処理項目の表示
- キャンセル操作の対応

#### 1.3.2 国際化・アクセシビリティ

**多言語対応**:
- メッセージリソースの外部化
- 動的言語切り替え機能
- 日時・数値の地域別フォーマット
- 文字エンコーディング統一

**アクセシビリティ**:
- スクリーンリーダー対応
- 色覚障害者向け表示調整
- キーボード操作のみでの操作
- 読み上げ対応テキスト

## 2. Application Layer コンポーネント

### 2.1 WalletCollectorService（ウォレット収集サービス）

#### 2.1.1 サービス設計

**責務範囲**:
- トークン保有者の包括的収集
- 保有量データの正規化処理
- キャッシュ機能の統合管理
- 収集結果の検証・補正

**依存関係**:
- TokenService（トークン操作）
- CacheService（キャッシュ管理）
- ConfigManager（設定取得）
- Logger（ログ出力）

#### 2.1.2 核心メソッド仕様

**collectWallets(tokenAddress: string, filter: WalletFilter): Promise<WalletData[]>**

*処理フロー*:
1. **事前検証**: トークンアドレスの妥当性確認
2. **キャッシュ確認**: 有効なキャッシュデータの存在確認
3. **オンチェーン取得**: Solana RPC からの実データ取得
4. **データ正規化**: 保有量・比率の計算
5. **フィルタリング**: 指定条件による絞り込み
   - **残高フィルター**: 最小・最大保有量による絞り込み
   - **アドレス除外フィルター**: `excludeAddresses`による特定アドレス除外
     - 管理者ウォレットの除外（大口保有者除外用途）
     - コントラクトアドレス・バーンアドレスの除外
     - カンマ区切りの複数アドレス対応: `--exclude "addr1,addr2,addr3"`
     - Base58形式の検証と無効アドレスの警告
6. **キャッシュ更新**: 取得結果のキャッシュ保存
7. **結果返却**: 最終的なウォレットリスト

*エラー処理*:
- **NetworkError**: ネットワーク接続失敗
- **InvalidTokenError**: 無効なトークンアドレス
- **DataCorruptionError**: データ整合性エラー
- **TimeoutError**: 処理タイムアウト

*パフォーマンス最適化*:
- **バッチ処理**: 100件単位での並行処理
- **進捗通知**: イベントベースの進捗報告
- **早期終了**: 条件達成時の処理中断
- **リソース管理**: メモリ使用量の制御

**validateWallets(wallets: WalletData[]): Promise<WalletData[]>**

*検証項目*:
- アドレス形式の正当性
- アカウント実在性の確認
- 残高データの整合性
- 重複エントリの検出

*修復処理*:
- 無効アドレスの除外
- 重複データの統合
- 不整合データの補正
- 検証結果のログ記録

#### 2.1.3 キャッシュ戦略

**キャッシュキー設計**:
- 形式: `wallet_{tokenAddress}_{filterHash}`
- フィルターハッシュ: フィルター条件のハッシュ値
- 一意性: 同一条件での重複回避

**無効化戦略**:
- **時間ベース**: 5分間のTTL設定
- **イベントベース**: トークン供給量変更時
- **手動無効化**: 明示的なキャッシュクリア

### 2.2 DistributionService（配布実行サービス）

#### 2.2.1 配布アルゴリズム詳細

**比例配分計算**:
```
各受信者への配布量 = floor((受信者保有量 / 総保有量) * 配布総額)
```

**精度保証メカニズム**:
- 整数演算による計算精度確保
- 端数処理による総額整合性維持
- 最小配布単位による公平性保証

**端数処理方式**:
1. 各受信者の配布量を整数で計算
2. 配布総額と計算結果の差額を算出
3. 差額を保有量上位者から順に1単位ずつ配分
4. 総額の完全一致を保証

#### 2.2.2 バッチ処理設計

**バッチサイズ制御**:
- デフォルト: 10トランザクション/バッチ
- 動的調整: ネットワーク状況による自動調整
- 設定可能: ユーザー指定による上書き

**並行処理制御**:
- セマフォによる同時実行数制限
- リソースプールの効率的活用
- デッドロック回避機構

**失敗時対応**:
- **個別リトライ**: 失敗トランザクションの個別再実行
- **バッチ再実行**: バッチ全体の再実行判定
- **部分成功処理**: 成功分の記録と残り処理継続

#### 2.2.3 状態管理

**配布実行状態**:
- **PREPARING**: 事前準備中
- **CALCULATING**: 配布量計算中
- **EXECUTING**: トランザクション実行中
- **COMPLETING**: 完了処理中
- **COMPLETED**: 実行完了
- **FAILED**: 実行失敗

**進捗追跡**:
- 全体進捗率の算出
- 現在処理中のバッチ情報
- 成功・失敗数のリアルタイム更新
- 推定完了時間の計算

### 2.3 ConfigurationService（設定管理サービス）

#### 2.3.1 設定階層管理

**設定優先順位**:
1. コマンドライン引数
2. 環境変数
3. プロジェクト設定ファイル
4. グローバル設定ファイル
5. デフォルト値

**設定統合処理**:
- 階層的設定のマージ処理
- 型安全な設定値の変換
- 設定間の依存関係検証
- 設定変更の影響範囲分析

#### 2.3.2 設定検証機能

**形式検証**:
- JSON スキーマによる構造検証
- データ型の適合性確認
- 必須項目の存在確認
- 値範囲の妥当性検証

**意味検証**:
- トークンアドレスの実在確認
- ネットワーク設定の整合性確認
- ウォレットアドレスの形式確認
- 数値設定の論理的妥当性確認

**整合性検証**:
- 設定項目間の依存関係確認
- 循環参照の検出・防止
- 矛盾する設定の検出・警告
- 実行環境との適合性確認

## 3. Service Layer コンポーネント

### 3.1 TokenService（トークン操作サービス）

#### 3.1.1 Solana統合設計

**RPC クライアント管理**:
- 接続プールによる効率的な接続管理
- フェイルオーバー対応（複数エンドポイント）
- レート制限の自動制御
- 接続健全性の監視

**トランザクション構築**:
- SPL Token 転送命令の構築
- 関連アカウント（ATA）の自動作成
- 優先手数料の動的設定
- トランザクションサイズの最適化

#### 3.1.2 核心メソッド実装

**getTokenHolders(tokenAddress: string): Promise<TokenAccount[]>**

*実装アプローチ*:
1. **プログラムアカウント取得**: TOKEN_PROGRAM_ID への問い合わせ
2. **フィルタリング**: 指定トークンのアカウントのみ抽出
3. **残高取得**: 各アカウントの残高情報取得
4. **所有者特定**: アカウント所有者の特定
5. **データ統合**: 結果の統合・正規化

*最適化戦略*:
- **並行処理**: 複数アカウントの同時処理
- **キャッシュ活用**: メタデータの効率的キャッシュ
- **差分更新**: 前回取得からの変更分のみ処理

**transferToken(params: TransferParams): Promise<TransactionSignature>**

*トランザクション構築*:
1. **ATA確認**: 受信者のAssociated Token Account確認
2. **ATA作成**: 必要に応じてATA作成命令追加
3. **転送命令**: SPL Token転送命令の構築
4. **署名・送信**: トランザクションの署名・送信
5. **確認待機**: トランザクション確認の待機

*エラー処理*:
- **残高不足**: InsufficientBalanceError
- **無効受信者**: InvalidRecipientError
- **ネットワークエラー**: NetworkError
- **タイムアウト**: TransactionTimeoutError

#### 3.1.3 ネットワーク管理

**マルチネットワーク対応**:
- **動的切り替え**: 実行時ネットワーク変更
- **設定統合**: ネットワーク固有設定の管理
- **接続検証**: ネットワーク接続状態の確認

**エラー回復**:
- **自動リトライ**: 一時的障害からの自動回復
- **フォールバック**: 代替エンドポイントへの切り替え
- **回路ブレーカー**: 継続的障害時の処理停止

### 3.2 CacheService（キャッシュ管理サービス）

#### 3.2.1 キャッシュアーキテクチャ

**多層キャッシュ構造**:
- **L1（メモリキャッシュ）**: 高速アクセス用
- **L2（ディスクキャッシュ）**: 永続化用
- **L3（圧縮キャッシュ）**: 大容量データ用

**キャッシュ戦略**:
- **Write-Through**: 書き込み時の同期更新
- **Lazy Loading**: 必要時の遅延読み込み
- **TTL管理**: 時間ベースの自動無効化

#### 3.2.2 キャッシュキー設計

**キー命名規則**:
- 形式: `{category}:{identifier}:{version}`
- カテゴリ: データ種別（wallet、token、config等）
- 識別子: データ固有の識別子
- バージョン: データバージョンまたはハッシュ

**キー階層化**:
- ネームスペース分離による管理効率化
- ワイルドカード削除のサポート
- 関連データの一括操作

#### 3.2.3 容量管理・最適化

**LRU（Least Recently Used）実装**:
- アクセス頻度による自動削除
- メモリ使用量の上限制御
- ホットデータの優先保持

**圧縮・シリアライゼーション**:
- JSON データの効率的圧縮
- バイナリシリアライゼーション
- デルタ圧縮による差分管理

### 3.3 LoggerService（ログ管理サービス）

#### 3.3.1 ログ設計思想

**構造化ログ**:
- JSON形式による機械処理対応
- 階層化されたログレベル
- コンテキスト情報の自動付与
- 統一されたフォーマット

**ログレベル定義**:
- **TRACE**: 詳細なデバッグ情報
- **DEBUG**: 開発用デバッグ情報
- **INFO**: 一般的な実行情報
- **WARN**: 警告レベルの情報
- **ERROR**: エラー情報
- **FATAL**: 致命的なエラー

#### 3.3.2 ログ分割・ローテーション

**ログファイル分割**:
- **error.log**: エラーレベル以上
- **audit.log**: 監査対象の操作
- **performance.log**: パフォーマンス情報
- **combined.log**: 全ログの統合

**ローテーション戦略**:
- **サイズベース**: 10MB単位でのローテーション
- **時間ベース**: 日次ローテーション
- **圧縮保存**: 古いログファイルの自動圧縮
- **自動削除**: 保存期間を超えたログの削除

#### 3.3.3 監査ログ設計

**監査対象操作**:
- 設定変更操作
- 配布実行操作
- ウォレット収集操作
- 権限を要する操作

**監査ログフォーマット**:
- タイムスタンプ（ナノ秒精度）
- ユーザー識別情報
- 操作種別・対象
- 実行結果・影響範囲
- 関連するトランザクション情報

## 4. Infrastructure Layer コンポーネント

### 4.1 FileRepository（ファイル操作リポジトリ）

#### 4.1.1 ファイル操作抽象化

**CRUD操作の統一**:
- **Create**: 新規ファイル作成（排他制御付き）
- **Read**: ファイル読み込み（キャッシュ統合）
- **Update**: ファイル更新（アトミック操作）
- **Delete**: ファイル削除（安全削除）

**トランザクション操作**:
- **一貫性保証**: 複数ファイル操作の原子性
- **ロールバック**: 失敗時の状態復旧
- **ロック機構**: 並行アクセスの制御

#### 4.1.2 安全性・信頼性

**データ整合性**:
- **チェックサム**: ファイル整合性の検証
- **バックアップ**: 自動バックアップ機能
- **復旧**: 破損ファイルからの復旧

**セキュリティ**:
- **ファイル暗号化**: 機密データの暗号化保存
- **アクセス制御**: ファイル権限の適切な設定
- **監査証跡**: ファイル操作の完全な記録

### 4.2 NetworkManager（ネットワーク管理）

#### 4.1.1 接続管理

**接続プール管理**:
- **コネクション生成**: 需要に応じた動的生成
- **健全性チェック**: 定期的な接続状態確認
- **負荷分散**: 複数エンドポイント間の負荷分散

**フェイルオーバー**:
- **自動切り替え**: 障害検出時の自動切り替え
- **サーキットブレーカー**: 連続障害時の一時停止
- **復旧検知**: 障害回復時の自動復帰

#### 4.1.2 パフォーマンス最適化

**リクエスト最適化**:
- **バッチリクエスト**: 複数リクエストの統合
- **並行処理**: 独立リクエストの並行実行
- **キャッシュ統合**: レスポンスの効率的キャッシュ

**レート制限対応**:
- **自動調整**: API制限に応じた自動調整
- **優先度制御**: 重要度による優先度制御
- **キューイング**: リクエストの効率的キューイング