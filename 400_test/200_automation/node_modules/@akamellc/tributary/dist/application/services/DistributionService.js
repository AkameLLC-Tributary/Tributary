"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DistributionService = void 0;
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const SolanaRpcClient_1 = require("../../infrastructure/rpc/SolanaRpcClient");
const storage_1 = require("../../infrastructure/storage");
const Logger_1 = require("../../infrastructure/logging/Logger");
const models_1 = require("../../domain/models");
const errors_1 = require("../../domain/errors");
const parameters_1 = require("../../config/parameters");
class DistributionService {
    adminKeypair;
    rpcClient;
    storage;
    logger;
    batchSize;
    maxRetries;
    constructor(network, adminKeypair, options = {}) {
        this.adminKeypair = adminKeypair;
        const params = (0, parameters_1.getParameters)();
        this.rpcClient = options.rpcClient || new SolanaRpcClient_1.SolanaRpcClient({ network });
        this.storage = options.storage || new storage_1.FileStorage();
        this.logger = options.logger || (0, Logger_1.createLogger)('DistributionService');
        this.batchSize = options.batchSize || params.distribution.defaultBatchSize;
        this.maxRetries = options.maxRetries || params.network.maxRetries;
    }
    async executeDistribution(request, onProgress) {
        return this.logger.logOperation('executeDistribution', async () => {
            this.validateDistributionRequest(request);
            const distributionId = this.generateDistributionId();
            const distribution = new models_1.Distribution(distributionId, request);
            await this.validateTokenBalance(request);
            const batches = this.createBatches(request.holders, request.batchSize || this.batchSize);
            const startTime = Date.now();
            let completed = 0;
            let successful = 0;
            let failed = 0;
            this.logger.info('Starting token distribution', {
                distributionId,
                totalRecipients: request.holders.length,
                totalAmount: request.amount,
                batchCount: batches.length
            });
            for (const [batchIndex, batch] of batches.entries()) {
                this.logger.debug(`Processing batch ${batchIndex + 1}/${batches.length}`, {
                    batchSize: batch.length
                });
                const batchResults = await this.processBatch(batch, request.tokenAddress, request.amount, distributionId);
                for (const result of batchResults) {
                    distribution.addResult(result);
                    completed++;
                    if (result.status === 'confirmed') {
                        successful++;
                    }
                    else if (result.status === 'failed') {
                        failed++;
                    }
                    if (onProgress) {
                        const elapsed = Date.now() - startTime;
                        const rate = completed / (elapsed / 1000);
                        onProgress({
                            completed,
                            total: request.holders.length,
                            successful,
                            failed,
                            rate
                        });
                    }
                }
                const params = (0, parameters_1.getParameters)();
                await this.delay(params.distribution.batchDelayMs);
            }
            await this.saveDistribution(distribution);
            const duration = Date.now() - startTime;
            this.logger.info('Distribution completed', {
                distributionId,
                duration,
                successful,
                failed,
                totalAmount: distribution.getTotalAmount()
            });
            return distribution;
        }, {
            amount: request.amount,
            recipients: request.holders.length
        });
    }
    async simulateDistribution(request) {
        return this.logger.logOperation('simulateDistribution', async () => {
            this.validateDistributionRequest(request);
            const distributionAmounts = this.calculateDistributionAmounts(request.holders, request.amount, request.mode || 'proportional', request.minimumAmount || 0);
            const estimatedGasCost = this.estimateGasCost(request.holders.length);
            const estimatedDuration = this.estimateDuration(request.holders.length, request.batchSize || this.batchSize);
            const amounts = Array.from(distributionAmounts.values());
            const distributionBreakdown = {
                totalAmount: request.amount,
                recipientCount: request.holders.length,
                averageAmount: amounts.length > 0 ? amounts.reduce((a, b) => a + b, 0) / amounts.length : 0,
                minAmount: amounts.length > 0 ? Math.min(...amounts) : 0,
                maxAmount: amounts.length > 0 ? Math.max(...amounts) : 0
            };
            const riskFactors = await this.assessRiskFactors(request);
            return {
                estimatedGasCost,
                estimatedDuration,
                distributionBreakdown,
                riskFactors
            };
        }, {
            amount: request.amount,
            recipients: request.holders.length
        });
    }
    async validateDistribution(request) {
        const errors = [];
        const warnings = [];
        try {
            this.validateDistributionRequest(request);
        }
        catch (error) {
            if (error instanceof errors_1.ValidationError) {
                errors.push(error.message);
            }
        }
        try {
            await this.validateTokenBalance(request);
        }
        catch (error) {
            if (error instanceof errors_1.ResourceError) {
                errors.push(error.message);
            }
        }
        const duplicateAddresses = this.findDuplicateAddresses(request.holders);
        if (duplicateAddresses.length > 0) {
            warnings.push(`Found ${duplicateAddresses.length} duplicate recipient addresses`);
        }
        const zeroBalanceHolders = request.holders.filter(h => h.balance === 0);
        if (zeroBalanceHolders.length > 0) {
            warnings.push(`Found ${zeroBalanceHolders.length} recipients with zero balance`);
        }
        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }
    validateDistributionRequest(request) {
        if (!request.amount || request.amount <= 0) {
            throw new errors_1.ValidationError('Distribution amount must be positive');
        }
        if (!request.tokenAddress) {
            throw new errors_1.ValidationError('Token address is required');
        }
        if (!request.holders || request.holders.length === 0) {
            throw new errors_1.ValidationError('At least one recipient is required');
        }
        if (request.batchSize && request.batchSize <= 0) {
            throw new errors_1.ValidationError('Batch size must be positive');
        }
    }
    async detectTokenProgram(tokenAddress) {
        try {
            const connection = this.rpcClient.getConnection();
            const mintInfo = await connection.getAccountInfo(tokenAddress);
            if (!mintInfo) {
                throw new Error(`Token mint ${tokenAddress.toString()} not found`);
            }
            if (mintInfo.owner.equals(spl_token_1.TOKEN_2022_PROGRAM_ID)) {
                this.logger.info('Detected Token 2022', { tokenAddress: tokenAddress.toString() });
                return spl_token_1.TOKEN_2022_PROGRAM_ID;
            }
            this.logger.info('Detected Standard Token', { tokenAddress: tokenAddress.toString() });
            return spl_token_1.TOKEN_PROGRAM_ID;
        }
        catch (error) {
            this.logger.warn('Failed to detect token program, defaulting to standard token', {
                error: error instanceof Error ? error.message : 'Unknown error',
                tokenAddress: tokenAddress.toString()
            });
            return spl_token_1.TOKEN_PROGRAM_ID;
        }
    }
    async validateTokenBalance(request) {
        try {
            const connection = this.rpcClient.getConnection();
            const tokenProgram = await this.detectTokenProgram(request.tokenAddress);
            const adminTokenAccount = await (0, spl_token_1.getAssociatedTokenAddress)(request.tokenAddress, this.adminKeypair.publicKey, false, tokenProgram);
            const accountInfo = await connection.getAccountInfo(adminTokenAccount);
            if (!accountInfo) {
                this.logger.info('Creating associated token account for admin wallet', {
                    tokenAddress: request.tokenAddress.toString(),
                    adminWallet: this.adminKeypair.publicKey.toString(),
                    tokenAccount: adminTokenAccount.toString()
                });
                const transaction = new web3_js_1.Transaction().add((0, spl_token_1.createAssociatedTokenAccountInstruction)(this.adminKeypair.publicKey, adminTokenAccount, this.adminKeypair.publicKey, request.tokenAddress, tokenProgram));
                await (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [this.adminKeypair]);
                this.logger.info('Associated token account created successfully', {
                    tokenAccount: adminTokenAccount.toString()
                });
            }
            const balance = await connection.getTokenAccountBalance(adminTokenAccount);
            const availableAmount = Number(balance.value.amount) / Math.pow(10, balance.value.decimals);
            if (availableAmount < request.amount) {
                throw new errors_1.ResourceError(`Insufficient token balance. Required: ${request.amount}, Available: ${availableAmount}`, { required: request.amount, available: availableAmount });
            }
            this.logger.info('Token balance validation successful', {
                required: request.amount,
                available: availableAmount,
                tokenAccount: adminTokenAccount.toString()
            });
        }
        catch (error) {
            if (error instanceof errors_1.ResourceError) {
                throw error;
            }
            throw new errors_1.NetworkError(`Failed to validate token balance: ${error instanceof Error ? error.message : 'Unknown error'}`, { tokenAddress: request.tokenAddress.toString() });
        }
    }
    async processBatch(batch, tokenAddress, totalAmount, distributionId) {
        const results = [];
        const distributionAmounts = this.calculateDistributionAmounts(batch, totalAmount, 'proportional', 0);
        for (const holder of batch) {
            const amount = distributionAmounts.get(holder.address.toString()) || 0;
            if (amount === 0) {
                continue;
            }
            const result = {
                transactionId: '',
                status: 'pending',
                recipient: holder.address,
                amount,
                timestamp: new Date()
            };
            try {
                result.transactionId = await this.sendTokens(holder.address, amount, tokenAddress, distributionId);
                result.status = 'confirmed';
                this.logger.debug('Token transfer successful', {
                    recipient: holder.address.toString(),
                    amount,
                    txId: result.transactionId
                });
            }
            catch (error) {
                result.status = 'failed';
                result.error = error instanceof Error ? error.message : String(error);
                this.logger.warn('Token transfer failed', {
                    recipient: holder.address.toString(),
                    amount,
                    error: result.error
                });
            }
            results.push(result);
        }
        return results;
    }
    async sendTokens(recipient, amount, tokenAddress, _distributionId) {
        const connection = this.rpcClient.getConnection();
        const tokenProgram = await this.detectTokenProgram(tokenAddress);
        const adminTokenAccount = await (0, spl_token_1.getAssociatedTokenAddress)(tokenAddress, this.adminKeypair.publicKey, false, tokenProgram);
        const recipientTokenAccount = await (0, spl_token_1.getAssociatedTokenAddress)(tokenAddress, recipient, false, tokenProgram);
        const transaction = new web3_js_1.Transaction();
        const instructions = [];
        const recipientAccountInfo = await connection.getAccountInfo(recipientTokenAccount);
        if (!recipientAccountInfo) {
            instructions.push((0, spl_token_1.createAssociatedTokenAccountInstruction)(this.adminKeypair.publicKey, recipientTokenAccount, recipient, tokenAddress, tokenProgram));
        }
        const decimals = await this.rpcClient.getTokenDecimals(tokenAddress);
        const adjustedAmount = Math.floor(amount * Math.pow(10, decimals));
        instructions.push((0, spl_token_1.createTransferInstruction)(adminTokenAccount, recipientTokenAccount, this.adminKeypair.publicKey, adjustedAmount, [], tokenProgram));
        transaction.add(...instructions);
        const { blockhash } = await connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = this.adminKeypair.publicKey;
        return await this.rpcClient.withRetry(async () => {
            return await (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [this.adminKeypair], {
                commitment: 'confirmed',
                maxRetries: this.maxRetries
            });
        });
    }
    calculateDistributionAmounts(holders, totalAmount, mode = 'proportional', minimumAmount = 0) {
        const distributionMap = new Map();
        if (holders.length === 0 || totalAmount <= 0) {
            return distributionMap;
        }
        if (mode === 'equal') {
            return this.calculateEqualDistribution(holders, totalAmount, minimumAmount);
        }
        else {
            return this.calculateProportionalDistribution(holders, totalAmount, minimumAmount);
        }
    }
    calculateEqualDistribution(holders, totalAmount, minimumAmount) {
        const distributionMap = new Map();
        const eligibleHolders = holders.filter(h => h.balance >= minimumAmount);
        if (eligibleHolders.length === 0) {
            return distributionMap;
        }
        const baseAmount = totalAmount / eligibleHolders.length;
        let distributedAmount = 0;
        for (let i = 0; i < eligibleHolders.length; i++) {
            const holder = eligibleHolders[i];
            let amount;
            if (i === eligibleHolders.length - 1) {
                amount = totalAmount - distributedAmount;
            }
            else {
                amount = Math.floor(baseAmount * 1000000) / 1000000;
            }
            if (amount > 0) {
                distributionMap.set(holder.address.toString(), amount);
                distributedAmount += amount;
            }
        }
        return distributionMap;
    }
    calculateProportionalDistribution(holders, totalAmount, minimumAmount) {
        const distributionMap = new Map();
        const eligibleHolders = holders.filter(h => h.balance >= minimumAmount);
        const totalBalance = eligibleHolders.reduce((sum, holder) => sum + holder.balance, 0);
        if (totalBalance === 0 || eligibleHolders.length === 0) {
            return distributionMap;
        }
        const PRECISION_MULTIPLIER = 1000000000;
        let remainingAmount = Math.round(totalAmount * PRECISION_MULTIPLIER);
        const totalBalancePrecise = Math.round(totalBalance * PRECISION_MULTIPLIER);
        const preciseAmounts = [];
        for (const holder of eligibleHolders) {
            const balancePrecise = Math.round(holder.balance * PRECISION_MULTIPLIER);
            const exactAmount = (remainingAmount * balancePrecise) / totalBalancePrecise;
            const flooredAmount = Math.floor(exactAmount);
            const remainder = exactAmount - flooredAmount;
            preciseAmounts.push({
                address: holder.address.toString(),
                amount: flooredAmount / PRECISION_MULTIPLIER,
                remainder
            });
        }
        preciseAmounts.sort((a, b) => b.remainder - a.remainder);
        let totalDistributed = preciseAmounts.reduce((sum, item) => sum + Math.round(item.amount * PRECISION_MULTIPLIER), 0);
        const undistributedAmount = remainingAmount - totalDistributed;
        const remainderUnits = Math.round(undistributedAmount);
        for (let i = 0; i < Math.min(remainderUnits, preciseAmounts.length); i++) {
            preciseAmounts[i].amount += 1 / PRECISION_MULTIPLIER;
        }
        for (const item of preciseAmounts) {
            if (item.amount > 0) {
                distributionMap.set(item.address, item.amount);
            }
        }
        return distributionMap;
    }
    createBatches(items, batchSize) {
        const batches = [];
        for (let i = 0; i < items.length; i += batchSize) {
            batches.push(items.slice(i, i + batchSize));
        }
        return batches;
    }
    estimateGasCost(recipientCount) {
        const params = (0, parameters_1.getParameters)();
        return recipientCount * params.distribution.estimatedGasPerTransaction;
    }
    estimateDuration(recipientCount, batchSize) {
        const params = (0, parameters_1.getParameters)();
        const batchCount = Math.ceil(recipientCount / batchSize);
        return batchCount * params.distribution.estimatedTimePerBatchSeconds * 1000;
    }
    async assessRiskFactors(request) {
        const params = (0, parameters_1.getParameters)();
        const risks = [];
        if (request.amount > params.distribution.riskThresholds.largeAmountThreshold) {
            risks.push('Large distribution amount may require additional confirmation');
        }
        if (request.holders.length > params.distribution.riskThresholds.largeRecipientCountThreshold) {
            risks.push('Large number of recipients may result in longer execution time');
        }
        const smallAmounts = request.holders.filter(h => (request.amount * h.percentage / 100) < params.distribution.riskThresholds.smallAmountThreshold);
        if (smallAmounts.length > 0) {
            risks.push(`${smallAmounts.length} recipients will receive very small amounts`);
        }
        return risks;
    }
    findDuplicateAddresses(holders) {
        const addressCounts = new Map();
        const duplicates = [];
        for (const holder of holders) {
            const address = holder.address.toString();
            const count = addressCounts.get(address) || 0;
            addressCounts.set(address, count + 1);
            if (count === 1) {
                duplicates.push(address);
            }
        }
        return duplicates;
    }
    generateDistributionId() {
        return `dist_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    async saveDistribution(distribution) {
        try {
            const filename = `distribution_${distribution.id}.json`;
            await this.storage.writeJson(filename, {
                id: distribution.id,
                request: distribution.request,
                results: distribution.getResults(),
                createdAt: distribution.createdAt,
                completed: distribution.isCompleted(),
                successfulCount: distribution.getSuccessfulCount(),
                failedCount: distribution.getFailedCount(),
                totalAmount: distribution.getTotalAmount()
            });
            this.logger.debug('Distribution saved to storage', {
                distributionId: distribution.id,
                filename
            });
        }
        catch (error) {
            this.logger.error('Failed to save distribution', {
                distributionId: distribution.id,
                error: error instanceof Error ? error.message : String(error)
            });
        }
    }
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    async getDistributionHistory() {
        return this.logger.logOperation('getDistributionHistory', async () => {
            const files = await this.storage.list();
            const distributionFiles = files.filter(file => file.startsWith('distribution_'));
            const distributions = [];
            for (const file of distributionFiles) {
                try {
                    const data = await this.storage.readJson(file);
                    const distribution = new models_1.Distribution(data.id, data.request, new Date(data.createdAt));
                    for (const result of data.results) {
                        distribution.addResult(result);
                    }
                    distributions.push(distribution);
                }
                catch (error) {
                    this.logger.warn('Failed to load distribution file', {
                        file,
                        error: error instanceof Error ? error.message : String(error)
                    });
                }
            }
            return distributions.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
        });
    }
}
exports.DistributionService = DistributionService;
//# sourceMappingURL=DistributionService.js.map