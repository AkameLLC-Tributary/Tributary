"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletCollectorService = void 0;
const SolanaRpcClient_1 = require("../../infrastructure/rpc/SolanaRpcClient");
const storage_1 = require("../../infrastructure/storage");
const Logger_1 = require("../../infrastructure/logging/Logger");
const errors_1 = require("../../domain/errors");
const parameters_1 = require("../../config/parameters");
class WalletCollectorService {
    rpcClient;
    storage;
    logger;
    constructor(network, options = {}) {
        this.rpcClient = options.rpcClient || new SolanaRpcClient_1.SolanaRpcClient({ network });
        this.storage = options.storage || new storage_1.FileStorage();
        this.logger = options.logger || (0, Logger_1.createLogger)('WalletCollectorService');
    }
    async collectWallets(options, onProgress) {
        return this.logger.logOperation('collectWallets', async () => {
            this.validateOptions(options);
            const cacheKey = this.generateCacheKey(options);
            if (options.useCache !== false) {
                const cached = await this.getCachedResult(cacheKey);
                if (cached) {
                    this.logger.info('Returning cached wallet data', {
                        tokenAddress: options.tokenAddress.toString(),
                        count: cached.length
                    });
                    return cached;
                }
            }
            const holders = await this.fetchTokenHolders(options, onProgress);
            const filteredHolders = this.applyFilters(holders, options);
            if (options.useCache !== false) {
                const params = (0, parameters_1.getParameters)();
                await this.cacheResult(cacheKey, filteredHolders, options.cacheTtl || params.cache.walletCacheTtlSeconds);
            }
            this.logger.info('Wallet collection completed', {
                tokenAddress: options.tokenAddress.toString(),
                totalHolders: holders.length,
                filteredHolders: filteredHolders.length,
                threshold: options.threshold
            });
            return filteredHolders;
        }, {
            tokenAddress: options.tokenAddress.toString(),
            threshold: options.threshold
        });
    }
    validateOptions(options) {
        if (!options.tokenAddress) {
            throw new errors_1.ValidationError('Token address is required');
        }
        if (options.threshold !== undefined && options.threshold < 0) {
            throw new errors_1.ValidationError('Threshold must be non-negative');
        }
        if (options.maxHolders !== undefined && options.maxHolders <= 0) {
            throw new errors_1.ValidationError('Max holders must be positive');
        }
        if (options.cacheTtl !== undefined && options.cacheTtl <= 0) {
            throw new errors_1.ValidationError('Cache TTL must be positive');
        }
    }
    async fetchTokenHolders(options, onProgress) {
        try {
            this.logger.info('Starting token holder fetch', {
                tokenAddress: options.tokenAddress.toString()
            });
            const isValid = await this.rpcClient.validateTokenAddress(options.tokenAddress);
            if (!isValid) {
                throw new errors_1.ValidationError(`Invalid or non-existent token address: ${options.tokenAddress.toString()}`);
            }
            const startTime = Date.now();
            const holders = await this.rpcClient.getTokenHolders(options.tokenAddress, options.threshold || 0);
            const duration = Date.now() - startTime;
            const rate = holders.length / (duration / 1000);
            if (onProgress) {
                onProgress({
                    current: holders.length,
                    total: holders.length,
                    rate
                });
            }
            return holders;
        }
        catch (error) {
            if (error instanceof errors_1.NetworkError) {
                throw error;
            }
            throw new errors_1.NetworkError(`Failed to fetch token holders: ${error instanceof Error ? error.message : 'Unknown error'}`, { tokenAddress: options.tokenAddress.toString() });
        }
    }
    applyFilters(holders, options) {
        let filtered = [...holders];
        if (options.threshold && options.threshold > 0) {
            filtered = filtered.filter(holder => holder.balance >= options.threshold);
        }
        if (options.excludeAddresses && options.excludeAddresses.length > 0) {
            const excludeSet = new Set(options.excludeAddresses.map(addr => addr.toString()));
            filtered = filtered.filter(holder => !excludeSet.has(holder.address.toString()));
        }
        if (options.maxHolders && options.maxHolders > 0) {
            filtered = filtered.slice(0, options.maxHolders);
        }
        filtered.sort((a, b) => b.balance - a.balance);
        return filtered;
    }
    async validateTokenAddress(tokenAddress) {
        return this.logger.logOperation('validateTokenAddress', async () => {
            try {
                return await this.rpcClient.validateTokenAddress(tokenAddress);
            }
            catch (error) {
                this.logger.warn('Token address validation failed', {
                    tokenAddress: tokenAddress.toString(),
                    error: error instanceof Error ? error.message : String(error)
                });
                return false;
            }
        }, { tokenAddress: tokenAddress.toString() });
    }
    async getTokenSupply(tokenAddress) {
        return this.logger.logOperation('getTokenSupply', async () => {
            return await this.rpcClient.getTokenSupply(tokenAddress);
        }, { tokenAddress: tokenAddress.toString() });
    }
    async exportWallets(holders, format = 'json', filePath) {
        return this.logger.logOperation('exportWallets', async () => {
            const params = (0, parameters_1.getParameters)();
            const timestamp = Date.now();
            const defaultPath = params.export.fileNamePattern
                .replace('{type}', 'wallets')
                .replace('{timestamp}', timestamp.toString())
                .replace('{format}', format);
            const exportPath = filePath || defaultPath;
            if (format === 'json') {
                await this.storage.writeJson(exportPath, holders);
            }
            else if (format === 'csv') {
                const csvContent = this.convertToCsv(holders);
                await this.storage.writeText(exportPath, csvContent);
            }
            this.logger.info('Wallet data exported', {
                format,
                path: exportPath,
                count: holders.length
            });
            return this.storage.getFullPath(exportPath);
        }, { format, count: holders.length });
    }
    convertToCsv(holders) {
        const headers = ['Address', 'Balance', 'Percentage'];
        const rows = holders.map(holder => [
            holder.address.toString(),
            holder.balance.toString(),
            holder.percentage.toFixed(4)
        ]);
        return [headers, ...rows]
            .map(row => row.join(','))
            .join('\n');
    }
    generateCacheKey(options) {
        const parts = [
            'wallets',
            options.tokenAddress.toString(),
            options.threshold || 0,
            options.maxHolders || 'unlimited',
            options.excludeAddresses?.map(addr => addr.toString()).join('|') || 'none'
        ];
        return parts.join('_');
    }
    async getCachedResult(cacheKey) {
        try {
            return await this.storage.readCache(cacheKey);
        }
        catch (error) {
            this.logger.warn('Failed to read cache', {
                cacheKey,
                error: error instanceof Error ? error.message : String(error)
            });
            return null;
        }
    }
    async cacheResult(cacheKey, holders, ttlSeconds) {
        try {
            await this.storage.writeCache(cacheKey, holders, ttlSeconds);
            this.logger.debug('Cached wallet data', {
                cacheKey,
                count: holders.length,
                ttl: ttlSeconds
            });
        }
        catch (error) {
            this.logger.warn('Failed to cache result', {
                cacheKey,
                error: error instanceof Error ? error.message : String(error)
            });
        }
    }
    async clearCache() {
        return this.logger.logOperation('clearCache', async () => {
            await this.storage.clearCache();
        });
    }
}
exports.WalletCollectorService = WalletCollectorService;
//# sourceMappingURL=WalletCollectorService.js.map