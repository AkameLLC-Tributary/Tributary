"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigManager = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const toml = __importStar(require("toml"));
const zod_1 = require("zod");
const web3_js_1 = require("@solana/web3.js");
const errors_1 = require("../../domain/errors");
const Logger_1 = require("../logging/Logger");
const parameters_1 = require("../../config/parameters");
const ProjectConfigSchema = zod_1.z.object({
    project: zod_1.z.object({
        name: zod_1.z.string().min(1).max(100),
        created: zod_1.z.string().datetime().optional(),
        network: zod_1.z.enum(['devnet', 'testnet', 'mainnet-beta'])
    }),
    token: zod_1.z.object({
        base_token: zod_1.z.string().refine(addr => {
            try {
                new web3_js_1.PublicKey(addr);
                return true;
            }
            catch {
                return false;
            }
        }, 'Invalid Solana address format'),
        admin_wallet: zod_1.z.string().refine(addr => {
            try {
                new web3_js_1.PublicKey(addr);
                return true;
            }
            catch {
                return false;
            }
        }, 'Invalid Solana address format')
    }),
    distribution: zod_1.z.object({
        schedule: zod_1.z.enum(['manual', 'weekly', 'monthly']).optional(),
        reward_token: zod_1.z.string().optional(),
        auto_distribute: zod_1.z.boolean().optional(),
        minimum_balance: zod_1.z.number().min(0).optional(),
        batch_size: zod_1.z.number().int().min(1).max(100).optional()
    }),
    security: zod_1.z.object({
        key_encryption: zod_1.z.boolean().optional(),
        backup_enabled: zod_1.z.boolean().optional(),
        audit_log: zod_1.z.boolean().optional()
    }),
    network: zod_1.z.object({
        rpc_urls: zod_1.z.object({
            devnet: zod_1.z.string().url().optional(),
            testnet: zod_1.z.string().url().optional(),
            'mainnet-beta': zod_1.z.string().url().optional()
        }).optional(),
        timeout: zod_1.z.number().int().min(1000).max(300000).optional(),
        max_retries: zod_1.z.number().int().min(1).max(10).optional(),
        retry_delay: zod_1.z.number().int().min(100).max(10000).optional()
    }).optional(),
    logging: zod_1.z.object({
        level: zod_1.z.enum(['debug', 'info', 'warn', 'error']).optional(),
        log_dir: zod_1.z.string().optional(),
        enable_console: zod_1.z.boolean().optional(),
        enable_file: zod_1.z.boolean().optional(),
        max_files: zod_1.z.number().int().min(1).max(100).optional(),
        max_size: zod_1.z.string().optional()
    }).optional()
});
function applyParameterDefaults(rawConfig) {
    const params = (0, parameters_1.getParameters)();
    const configWithDefaults = {
        project: {
            name: rawConfig.project?.name,
            created: rawConfig.project?.created,
            network: rawConfig.project?.network
        },
        token: {
            base_token: rawConfig.token?.base_token,
            admin_wallet: rawConfig.token?.admin_wallet
        },
        distribution: {
            schedule: rawConfig.distribution?.schedule,
            reward_token: rawConfig.distribution?.reward_token,
            auto_distribute: rawConfig.distribution?.auto_distribute ?? false,
            minimum_balance: rawConfig.distribution?.minimum_balance ?? params.token.minimumBalance,
            batch_size: rawConfig.distribution?.batch_size ?? params.distribution.defaultBatchSize
        },
        security: {
            key_encryption: rawConfig.security?.key_encryption ?? params.security.defaultKeyEncryption,
            backup_enabled: rawConfig.security?.backup_enabled ?? params.security.defaultBackupEnabled,
            audit_log: rawConfig.security?.audit_log ?? params.security.defaultAuditLog
        },
        network: {
            rpc_urls: rawConfig.network?.rpc_urls,
            timeout: rawConfig.network?.timeout ?? params.network.timeout,
            max_retries: rawConfig.network?.max_retries ?? params.network.maxRetries,
            retry_delay: rawConfig.network?.retry_delay ?? params.network.retryDelay
        },
        logging: {
            level: rawConfig.logging?.level ?? params.logging.defaultLevel,
            log_dir: rawConfig.logging?.log_dir ?? params.logging.defaultDir,
            enable_console: rawConfig.logging?.enable_console !== undefined ? rawConfig.logging.enable_console : params.logging.enableConsole,
            enable_file: rawConfig.logging?.enable_file !== undefined ? rawConfig.logging.enable_file : params.logging.enableFile,
            max_files: rawConfig.logging?.max_files !== undefined ? rawConfig.logging.max_files : params.logging.maxFiles,
            max_size: rawConfig.logging?.max_size ?? params.logging.maxFileSize
        }
    };
    return configWithDefaults;
}
class ConfigManager {
    config = null;
    configPath;
    logger;
    constructor(configPath = './tributary.toml') {
        this.configPath = path_1.default.resolve(configPath);
        this.logger = (0, Logger_1.createLogger)('ConfigManager');
    }
    async loadConfig() {
        return this.logger.logOperation('loadConfig', async () => {
            try {
                const configContent = await fs_1.promises.readFile(this.configPath, 'utf-8');
                const rawConfig = toml.parse(configContent);
                const validatedRawConfig = ProjectConfigSchema.parse(rawConfig);
                this.config = applyParameterDefaults(validatedRawConfig);
                this.logger.info('Configuration loaded successfully', {
                    configPath: this.configPath,
                    projectName: this.config.project.name,
                    network: this.config.project.network
                });
                return this.config;
            }
            catch (error) {
                if (error.code === 'ENOENT') {
                    throw new errors_1.ConfigurationError(`Configuration file not found: ${this.configPath}`, { configPath: this.configPath });
                }
                if (error instanceof zod_1.z.ZodError) {
                    const errorMessages = error.errors.map(err => `${err.path.join('.')}: ${err.message}`).join(', ');
                    throw new errors_1.ValidationError(`Invalid configuration: ${errorMessages}`, { errors: error.errors });
                }
                throw new errors_1.ConfigurationError(`Failed to load configuration: ${error instanceof Error ? error.message : 'Unknown error'}`, { configPath: this.configPath, error: String(error) });
            }
        });
    }
    async saveConfig(config) {
        return this.logger.logOperation('saveConfig', async () => {
            try {
                ProjectConfigSchema.parse(config);
                const configDir = path_1.default.dirname(this.configPath);
                await fs_1.promises.mkdir(configDir, { recursive: true });
                const tomlContent = this.stringifyToml(config);
                await fs_1.promises.writeFile(this.configPath, tomlContent, 'utf-8');
                this.config = config;
                this.logger.info('Configuration saved successfully', {
                    configPath: this.configPath,
                    projectName: config.project.name
                });
            }
            catch (error) {
                if (error instanceof zod_1.z.ZodError) {
                    const errorMessages = error.errors.map(err => `${err.path.join('.')}: ${err.message}`).join(', ');
                    throw new errors_1.ValidationError(`Invalid configuration: ${errorMessages}`, { errors: error.errors });
                }
                throw new errors_1.ConfigurationError(`Failed to save configuration: ${error instanceof Error ? error.message : 'Unknown error'}`, { configPath: this.configPath, error: String(error) });
            }
        });
    }
    async initializeProject(options) {
        return this.logger.logOperation('initializeProject', async () => {
            if (!options.force && await this.configExists()) {
                throw new errors_1.ConfigurationError('Configuration file already exists. Use --force to overwrite.', { configPath: this.configPath });
            }
            const params = (0, parameters_1.getParameters)();
            const baseConfig = {
                project: {
                    name: options.name,
                    created: new Date().toISOString(),
                    network: options.network
                },
                token: {
                    base_token: options.baseToken,
                    admin_wallet: options.adminWallet
                },
                distribution: {
                    auto_distribute: false,
                    minimum_balance: params.token.minimumBalance,
                    batch_size: params.distribution.defaultBatchSize,
                    ...options.overrides?.distribution
                },
                security: {
                    key_encryption: params.security.defaultKeyEncryption,
                    backup_enabled: params.security.defaultBackupEnabled,
                    audit_log: params.security.defaultAuditLog,
                    ...options.overrides?.security
                },
                network: {
                    timeout: params.network.timeout,
                    max_retries: params.network.maxRetries,
                    retry_delay: params.network.retryDelay,
                    rpc_urls: this.getDefaultRpcUrls(options.customRpcUrls),
                    ...options.overrides?.network
                },
                logging: {
                    level: params.logging.defaultLevel,
                    log_dir: params.logging.defaultDir,
                    enable_console: params.logging.enableConsole,
                    enable_file: params.logging.enableFile,
                    max_files: params.logging.maxFiles,
                    max_size: params.logging.maxFileSize,
                    ...options.overrides?.logging
                }
            };
            const config = baseConfig;
            await this.saveConfig(config);
            this.logger.info('Project initialized successfully', {
                projectName: options.name,
                network: options.network,
                configPath: this.configPath
            });
            return config;
        }, options);
    }
    getConfig() {
        if (!this.config) {
            throw new errors_1.ConfigurationError('Configuration not loaded. Call loadConfig() first.', { configPath: this.configPath });
        }
        return this.config;
    }
    getProjectConfig() {
        const config = this.getConfig();
        return {
            name: config.project.name,
            network: config.project.network,
            baseToken: new web3_js_1.PublicKey(config.token.base_token),
            adminWallet: new web3_js_1.PublicKey(config.token.admin_wallet),
            distributionSettings: {
                schedule: config.distribution.schedule,
                rewardToken: config.distribution.reward_token
                    ? new web3_js_1.PublicKey(config.distribution.reward_token)
                    : undefined,
                autoDistribute: config.distribution.auto_distribute ?? false,
                minimumBalance: config.distribution.minimum_balance ?? 0,
                batchSize: config.distribution.batch_size ?? 10
            },
            securitySettings: {
                keyEncryption: config.security.key_encryption ?? false,
                backupEnabled: config.security.backup_enabled ?? false,
                auditLog: config.security.audit_log ?? false
            }
        };
    }
    getNetworkConfig() {
        const config = this.getConfig();
        const params = (0, parameters_1.getParameters)();
        const currentNetwork = config.project.network;
        const networkRpcUrl = config.network?.rpc_urls?.[currentNetwork];
        return {
            network: currentNetwork,
            rpcUrl: networkRpcUrl,
            timeout: config.network?.timeout || params.network.timeout,
            maxRetries: config.network?.max_retries || params.network.maxRetries,
            retryDelay: config.network?.retry_delay || params.network.retryDelay
        };
    }
    getLoggingConfig() {
        const config = this.getConfig();
        const params = (0, parameters_1.getParameters)();
        return {
            level: config.logging?.level || params.logging.defaultLevel,
            logDir: config.logging?.log_dir || params.logging.defaultDir,
            enableConsole: config.logging?.enable_console ?? params.logging.enableConsole,
            enableFile: config.logging?.enable_file ?? params.logging.enableFile,
            maxFiles: config.logging?.max_files || params.logging.maxFiles,
            maxSize: config.logging?.max_size || params.logging.maxFileSize
        };
    }
    async updateConfig(updates) {
        return this.logger.logOperation('updateConfig', async () => {
            const currentConfig = this.getConfig();
            const mergedConfig = this.deepMerge(currentConfig, updates);
            await this.saveConfig(mergedConfig);
        }, { updates });
    }
    async validateConfig(configPath) {
        const pathToValidate = configPath || this.configPath;
        const errors = [];
        const warnings = [];
        try {
            const configContent = await fs_1.promises.readFile(pathToValidate, 'utf-8');
            const rawConfig = toml.parse(configContent);
            ProjectConfigSchema.parse(rawConfig);
            if (rawConfig.project?.network === 'mainnet-beta') {
                warnings.push('Using mainnet-beta network - ensure you have sufficient funds');
            }
            if (!rawConfig.security?.key_encryption) {
                warnings.push('Key encryption is disabled - consider enabling for better security');
            }
            if (!rawConfig.security?.backup_enabled) {
                warnings.push('Backup is disabled - consider enabling to prevent data loss');
            }
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                errors.push(`Configuration file not found: ${pathToValidate}`);
            }
            else if (error instanceof zod_1.z.ZodError) {
                errors.push(...error.errors.map(err => `${err.path.join('.')}: ${err.message}`));
            }
            else {
                errors.push(`Failed to parse configuration: ${error instanceof Error ? error.message : 'Unknown error'}`);
            }
        }
        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }
    async configExists() {
        try {
            await fs_1.promises.access(this.configPath);
            return true;
        }
        catch {
            return false;
        }
    }
    getConfigPath() {
        return this.configPath;
    }
    setConfigPath(configPath) {
        this.configPath = path_1.default.resolve(configPath);
        this.config = null;
    }
    stringifyToml(obj) {
        const lines = [];
        const stringify = (value, prefix = '') => {
            if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                if (prefix) {
                    lines.push(`[${prefix}]`);
                }
                for (const [key, val] of Object.entries(value)) {
                    const fullKey = prefix ? `${prefix}.${key}` : key;
                    if (typeof val === 'object' && val !== null && !Array.isArray(val)) {
                        stringify(val, fullKey);
                    }
                    else {
                        const tomlValue = this.formatTomlValue(val);
                        lines.push(`${key} = ${tomlValue}`);
                    }
                }
                if (prefix) {
                    lines.push('');
                }
            }
        };
        stringify(obj);
        return lines.join('\n');
    }
    formatTomlValue(value) {
        if (typeof value === 'string') {
            return `"${value.replace(/"/g, '\\"')}"`;
        }
        if (typeof value === 'boolean') {
            return value.toString();
        }
        if (typeof value === 'number') {
            return value.toString();
        }
        if (Array.isArray(value)) {
            return `[${value.map(v => this.formatTomlValue(v)).join(', ')}]`;
        }
        return `"${String(value)}"`;
    }
    deepMerge(target, source) {
        const result = { ...target };
        for (const key in source) {
            if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                result[key] = this.deepMerge(result[key] || {}, source[key]);
            }
            else {
                result[key] = source[key];
            }
        }
        return result;
    }
    getDefaultRpcUrls(customUrls) {
        const params = (0, parameters_1.getParameters)();
        const defaultUrls = {
            devnet: customUrls?.devnet || process.env.TRIBUTARY_DEVNET_RPC || params.rpc.endpoints.devnet,
            testnet: customUrls?.testnet || process.env.TRIBUTARY_TESTNET_RPC || params.rpc.endpoints.testnet,
            "mainnet-beta": customUrls?.['mainnet-beta'] || process.env.TRIBUTARY_MAINNET_RPC || params.rpc.endpoints['mainnet-beta']
        };
        this.logger.info('Using default RPC URLs', {
            devnet: defaultUrls.devnet,
            testnet: defaultUrls.testnet,
            'mainnet-beta': defaultUrls['mainnet-beta']
        });
        return defaultUrls;
    }
}
exports.ConfigManager = ConfigManager;
//# sourceMappingURL=ConfigManager.js.map