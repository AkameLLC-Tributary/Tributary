"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLogger = exports.Logger = void 0;
const winston_1 = __importDefault(require("winston"));
const path_1 = __importDefault(require("path"));
class Logger {
    logger;
    component;
    constructor(component, options = {}) {
        this.component = component;
        this.logger = this.createLogger(options);
    }
    createLogger(options) {
        const { level = 'info', logDir = './logs', enableConsole = true, enableFile = true, maxFiles = 14, maxSize = '20m' } = options;
        const formats = [
            winston_1.default.format.timestamp(),
            winston_1.default.format.errors({ stack: true }),
            winston_1.default.format.json()
        ];
        const transports = [];
        if (enableConsole) {
            transports.push(new winston_1.default.transports.Console({
                format: winston_1.default.format.combine(winston_1.default.format.colorize(), winston_1.default.format.simple(), winston_1.default.format.printf(({ timestamp, level, message, component, operation, ...meta }) => {
                    const metaStr = Object.keys(meta).length ? ` ${JSON.stringify(meta)}` : '';
                    const operationStr = operation ? ` [${operation}]` : '';
                    return `${timestamp} ${level}: [${component}]${operationStr} ${message}${metaStr}`;
                }))
            }));
        }
        if (enableFile) {
            transports.push(new winston_1.default.transports.File({
                filename: path_1.default.join(logDir, 'error.log'),
                level: 'error',
                format: winston_1.default.format.combine(...formats),
                maxFiles,
                maxsize: this.parseSize(maxSize)
            }), new winston_1.default.transports.File({
                filename: path_1.default.join(logDir, 'combined.log'),
                format: winston_1.default.format.combine(...formats),
                maxFiles,
                maxsize: this.parseSize(maxSize)
            }));
        }
        return winston_1.default.createLogger({
            level,
            format: winston_1.default.format.combine(...formats),
            defaultMeta: { component: this.component },
            transports,
            exitOnError: false
        });
    }
    parseSize(size) {
        const match = size.match(/^(\d+)([kmg]?)$/i);
        if (!match)
            return 20 * 1024 * 1024;
        const value = parseInt(match[1], 10);
        const unit = match[2].toLowerCase();
        switch (unit) {
            case 'k': return value * 1024;
            case 'm': return value * 1024 * 1024;
            case 'g': return value * 1024 * 1024 * 1024;
            default: return value;
        }
    }
    debug(message, meta) {
        this.log('debug', message, meta);
    }
    info(message, meta) {
        this.log('info', message, meta);
    }
    warn(message, meta) {
        this.log('warn', message, meta);
    }
    error(message, error) {
        const meta = error instanceof Error
            ? { error: error.message, stack: error.stack }
            : error;
        this.log('error', message, meta);
    }
    logOperation(operation, fn, meta) {
        return this.withPerformanceTracking(operation, fn, meta);
    }
    async withPerformanceTracking(operation, fn, meta) {
        const startTime = Date.now();
        this.debug(`Starting operation: ${operation}`, { operation, ...meta });
        try {
            const result = await fn();
            const duration = Date.now() - startTime;
            this.info(`Operation completed: ${operation}`, {
                operation,
                duration,
                success: true,
                ...meta
            });
            return result;
        }
        catch (error) {
            const duration = Date.now() - startTime;
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.error(`Operation failed: ${operation}`, {
                operation,
                duration,
                success: false,
                error: errorMessage,
                ...meta
            });
            throw error;
        }
    }
    log(level, message, meta) {
        const logEntry = {
            level,
            message,
            component: this.component,
            metadata: meta
        };
        this.logger.log(level, message, logEntry);
    }
    createChildLogger(childComponent) {
        const fullComponent = `${this.component}:${childComponent}`;
        return new Logger(fullComponent, {
            level: this.logger.level,
            enableConsole: this.hasConsoleTransport(),
            enableFile: this.hasFileTransport()
        });
    }
    hasConsoleTransport() {
        return this.logger.transports.some(t => t instanceof winston_1.default.transports.Console);
    }
    hasFileTransport() {
        return this.logger.transports.some(t => t instanceof winston_1.default.transports.File);
    }
    setLevel(level) {
        this.logger.level = level;
    }
    getLevel() {
        return this.logger.level;
    }
    close() {
        this.logger.close();
    }
}
exports.Logger = Logger;
const createLogger = (component, options) => {
    return new Logger(component, options);
};
exports.createLogger = createLogger;
//# sourceMappingURL=Logger.js.map