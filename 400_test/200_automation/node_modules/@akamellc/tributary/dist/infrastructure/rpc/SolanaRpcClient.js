"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolanaRpcClient = void 0;
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const errors_1 = require("../../domain/errors");
const parameters_1 = require("../../config/parameters");
class SolanaRpcClient {
    connection;
    timeout;
    maxRetries;
    retryDelay;
    constructor(options) {
        const params = (0, parameters_1.getParameters)();
        const rpcUrl = options.rpcUrl || this.getDefaultRpcUrl(options.network);
        this.connection = new web3_js_1.Connection(rpcUrl, {
            commitment: params.network.commitment,
            confirmTransactionInitialTimeout: options.timeout || params.network.confirmationTimeout
        });
        this.timeout = options.timeout || params.network.timeout;
        this.maxRetries = options.maxRetries || params.network.maxRetries;
        this.retryDelay = options.retryDelay || params.network.retryDelay;
    }
    getDefaultRpcUrl(network) {
        const params = (0, parameters_1.getParameters)();
        switch (network) {
            case 'devnet':
                return params.rpc.endpoints.devnet;
            case 'testnet':
                return params.rpc.endpoints.testnet;
            case 'mainnet-beta':
                return params.rpc.endpoints['mainnet-beta'];
            default:
                throw new errors_1.NetworkError(`Unknown network: ${network}`);
        }
    }
    async getTokenHolders(tokenMintAddress, threshold = 0) {
        try {
            return await this.withTimeout(this.fetchTokenHolders(tokenMintAddress, threshold), this.timeout);
        }
        catch (error) {
            if (error instanceof Error) {
                throw new errors_1.NetworkError(`Failed to fetch token holders: ${error.message}`, { tokenMint: tokenMintAddress.toString(), threshold });
            }
            throw error;
        }
    }
    async fetchTokenHolders(tokenMintAddress, threshold) {
        const tokenProgram = await this.detectTokenProgram(tokenMintAddress);
        if (tokenProgram.equals(spl_token_1.TOKEN_2022_PROGRAM_ID)) {
            return this.fetchToken2022Holders(tokenMintAddress, threshold);
        }
        const filters = [
            {
                dataSize: spl_token_1.AccountLayout.span
            },
            {
                memcmp: {
                    offset: spl_token_1.AccountLayout.offsetOf('mint') || 0,
                    bytes: tokenMintAddress.toBase58()
                }
            }
        ];
        const accounts = await this.connection.getProgramAccounts(spl_token_1.TOKEN_PROGRAM_ID, { filters });
        const holders = [];
        const decimals = await this.getTokenDecimals(tokenMintAddress);
        for (const account of accounts) {
            try {
                const accountData = spl_token_1.AccountLayout.decode(account.account.data);
                const balance = Number(accountData.amount) / Math.pow(10, decimals);
                if (balance >= threshold) {
                    holders.push({
                        address: new web3_js_1.PublicKey(accountData.owner),
                        balance,
                        percentage: 0
                    });
                }
            }
            catch (error) {
                console.warn(`Failed to decode account ${account.pubkey.toString()}: ${error}`);
            }
        }
        const totalSupply = holders.reduce((sum, holder) => sum + holder.balance, 0);
        holders.forEach(holder => {
            holder.percentage = (holder.balance / totalSupply) * 100;
        });
        return holders.sort((a, b) => b.balance - a.balance);
    }
    async getTokenSupply(tokenMintAddress) {
        try {
            const supply = await this.withTimeout(this.connection.getTokenSupply(tokenMintAddress), this.timeout);
            return Number(supply.value.amount) / Math.pow(10, supply.value.decimals);
        }
        catch (error) {
            if (error instanceof Error) {
                throw new errors_1.NetworkError(`Failed to fetch token supply: ${error.message}`, { tokenMint: tokenMintAddress.toString() });
            }
            throw error;
        }
    }
    async getTokenDecimals(tokenMintAddress) {
        try {
            const supply = await this.withTimeout(this.connection.getTokenSupply(tokenMintAddress), this.timeout);
            return supply.value.decimals;
        }
        catch (error) {
            if (error instanceof Error) {
                throw new errors_1.NetworkError(`Failed to fetch token decimals: ${error.message}`, { tokenMint: tokenMintAddress.toString() });
            }
            throw error;
        }
    }
    async validateTokenAddress(tokenAddress) {
        try {
            const accountInfo = await this.withTimeout(this.connection.getAccountInfo(tokenAddress), this.timeout);
            return accountInfo !== null && (accountInfo.owner.equals(spl_token_1.TOKEN_PROGRAM_ID) ||
                accountInfo.owner.equals(spl_token_1.TOKEN_2022_PROGRAM_ID));
        }
        catch {
            return false;
        }
    }
    async validateWalletAddress(walletAddress) {
        try {
            const accountInfo = await this.withTimeout(this.connection.getAccountInfo(walletAddress), this.timeout);
            return accountInfo !== null;
        }
        catch {
            return false;
        }
    }
    getConnection() {
        return this.connection;
    }
    async withTimeout(promise, timeoutMs) {
        return Promise.race([
            promise,
            new Promise((_, reject) => {
                setTimeout(() => {
                    reject(new errors_1.TimeoutError(`Operation timed out after ${timeoutMs}ms`));
                }, timeoutMs);
            })
        ]);
    }
    async withRetry(operation, maxRetries = this.maxRetries) {
        let lastError;
        for (let attempt = 0; attempt <= maxRetries; attempt++) {
            try {
                return await operation();
            }
            catch (error) {
                lastError = error instanceof Error ? error : new Error(String(error));
                if (attempt === maxRetries) {
                    throw new errors_1.NetworkError(`Operation failed after ${maxRetries + 1} attempts: ${lastError.message}`, { attempts: attempt + 1, lastError: lastError.message });
                }
                await this.delay(this.retryDelay * Math.pow(2, attempt));
            }
        }
        throw lastError;
    }
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    async detectTokenProgram(tokenMintAddress) {
        try {
            const accountInfo = await this.withTimeout(this.connection.getAccountInfo(tokenMintAddress), this.timeout);
            if (accountInfo?.owner.equals(spl_token_1.TOKEN_2022_PROGRAM_ID)) {
                return spl_token_1.TOKEN_2022_PROGRAM_ID;
            }
            return spl_token_1.TOKEN_PROGRAM_ID;
        }
        catch {
            return spl_token_1.TOKEN_PROGRAM_ID;
        }
    }
    async fetchToken2022Holders(tokenMintAddress, threshold) {
        try {
            const largestAccounts = await this.withTimeout(this.connection.getTokenLargestAccounts(tokenMintAddress), this.timeout);
            const holders = [];
            const decimals = await this.getTokenDecimals(tokenMintAddress);
            for (const account of largestAccounts.value) {
                const balance = Number(account.amount) / Math.pow(10, decimals);
                if (balance >= threshold) {
                    const accountInfo = await this.withTimeout(this.connection.getAccountInfo(account.address), this.timeout);
                    if (accountInfo) {
                        try {
                            const accountData = spl_token_1.AccountLayout.decode(accountInfo.data);
                            holders.push({
                                address: new web3_js_1.PublicKey(accountData.owner),
                                balance,
                                percentage: 0
                            });
                        }
                        catch (error) {
                            console.warn(`Failed to decode Token 2022 account ${account.address.toString()}: ${error}`);
                        }
                    }
                }
            }
            const totalSupply = holders.reduce((sum, holder) => sum + holder.balance, 0);
            holders.forEach(holder => {
                holder.percentage = totalSupply > 0 ? (holder.balance / totalSupply) * 100 : 0;
            });
            return holders.sort((a, b) => b.balance - a.balance);
        }
        catch (error) {
            console.warn(`Token 2022 holder fetch failed, falling back to transaction history method: ${error}`);
            return this.fetchToken2022HoldersByTransactions(tokenMintAddress, threshold);
        }
    }
    async fetchToken2022HoldersByTransactions(tokenMintAddress, threshold) {
        try {
            const signatures = await this.withTimeout(this.connection.getSignaturesForAddress(tokenMintAddress, { limit: 1000 }), this.timeout);
            const holderMap = new Map();
            const decimals = await this.getTokenDecimals(tokenMintAddress);
            for (const sigInfo of signatures) {
                try {
                    const transaction = await this.withTimeout(this.connection.getTransaction(sigInfo.signature, {
                        maxSupportedTransactionVersion: 0
                    }), this.timeout);
                    if (transaction?.meta?.postTokenBalances) {
                        for (const balance of transaction.meta.postTokenBalances) {
                            if (balance.mint === tokenMintAddress.toString() && balance.owner) {
                                const amount = Number(balance.uiTokenAmount.amount) / Math.pow(10, decimals);
                                if (amount > 0) {
                                    holderMap.set(balance.owner, Math.max(holderMap.get(balance.owner) || 0, amount));
                                }
                            }
                        }
                    }
                }
                catch (error) {
                    console.warn(`Failed to process transaction ${sigInfo.signature}: ${error}`);
                }
            }
            const holders = [];
            for (const [ownerAddress, balance] of holderMap.entries()) {
                if (balance >= threshold) {
                    holders.push({
                        address: new web3_js_1.PublicKey(ownerAddress),
                        balance,
                        percentage: 0
                    });
                }
            }
            const totalSupply = holders.reduce((sum, holder) => sum + holder.balance, 0);
            holders.forEach(holder => {
                holder.percentage = totalSupply > 0 ? (holder.balance / totalSupply) * 100 : 0;
            });
            return holders.sort((a, b) => b.balance - a.balance);
        }
        catch (error) {
            console.warn(`Token 2022 transaction-based holder fetch failed: ${error}`);
            return [];
        }
    }
}
exports.SolanaRpcClient = SolanaRpcClient;
//# sourceMappingURL=SolanaRpcClient.js.map