"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileStorage = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const errors_1 = require("../../domain/errors");
class FileStorage {
    baseDir;
    createDirs;
    constructor(options = {}) {
        this.baseDir = options.baseDir || './data';
        this.createDirs = options.createDirs ?? true;
    }
    async writeJson(filePath, data) {
        try {
            const fullPath = path_1.default.resolve(this.baseDir, filePath);
            if (this.createDirs) {
                await this.ensureDirectoryExists(path_1.default.dirname(fullPath));
            }
            const jsonData = JSON.stringify(data, null, 2);
            await fs_1.promises.writeFile(fullPath, jsonData, 'utf8');
        }
        catch (error) {
            throw new errors_1.ResourceError(`Failed to write JSON file: ${error instanceof Error ? error.message : 'Unknown error'}`, { filePath, error: String(error) });
        }
    }
    async writeText(filePath, content) {
        try {
            const fullPath = path_1.default.resolve(this.baseDir, filePath);
            if (this.createDirs) {
                await this.ensureDirectoryExists(path_1.default.dirname(fullPath));
            }
            await fs_1.promises.writeFile(fullPath, content, 'utf8');
        }
        catch (error) {
            throw new errors_1.ResourceError(`Failed to write text file: ${error instanceof Error ? error.message : 'Unknown error'}`, { filePath, error: String(error) });
        }
    }
    async readJson(filePath) {
        try {
            const fullPath = path_1.default.resolve(this.baseDir, filePath);
            const jsonData = await fs_1.promises.readFile(fullPath, 'utf8');
            return JSON.parse(jsonData);
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                throw new errors_1.ResourceError(`File not found: ${filePath}`, { filePath, error: 'ENOENT' });
            }
            throw new errors_1.DataIntegrityError(`Failed to read JSON file: ${error instanceof Error ? error.message : 'Unknown error'}`, { filePath, error: String(error) });
        }
    }
    async exists(filePath) {
        try {
            const fullPath = path_1.default.resolve(this.baseDir, filePath);
            await fs_1.promises.access(fullPath);
            return true;
        }
        catch {
            return false;
        }
    }
    async delete(filePath) {
        try {
            const fullPath = path_1.default.resolve(this.baseDir, filePath);
            await fs_1.promises.unlink(fullPath);
        }
        catch (error) {
            if (error.code !== 'ENOENT') {
                throw new errors_1.ResourceError(`Failed to delete file: ${error instanceof Error ? error.message : 'Unknown error'}`, { filePath, error: String(error) });
            }
        }
    }
    async list(dirPath = '') {
        try {
            const fullPath = path_1.default.resolve(this.baseDir, dirPath);
            const files = await fs_1.promises.readdir(fullPath);
            return files.filter(file => !file.startsWith('.'));
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                return [];
            }
            throw new errors_1.ResourceError(`Failed to list directory: ${error instanceof Error ? error.message : 'Unknown error'}`, { dirPath, error: String(error) });
        }
    }
    async writeCache(key, value, ttlSeconds) {
        const cacheData = {
            key,
            value,
            expiresAt: new Date(Date.now() + ttlSeconds * 1000),
            createdAt: new Date()
        };
        const cacheFile = `cache/${this.sanitizeKey(key)}.json`;
        await this.writeJson(cacheFile, cacheData);
    }
    async readCache(key) {
        try {
            const cacheFile = `cache/${this.sanitizeKey(key)}.json`;
            const cacheData = await this.readJson(cacheFile);
            if (new Date() > new Date(cacheData.expiresAt)) {
                await this.delete(cacheFile);
                return null;
            }
            return cacheData.value;
        }
        catch (error) {
            if (error instanceof errors_1.ResourceError && error.details?.error === 'ENOENT') {
                return null;
            }
            throw error;
        }
    }
    async clearCache() {
        try {
            const cacheFiles = await this.list('cache');
            await Promise.all(cacheFiles.map(file => this.delete(`cache/${file}`)));
        }
        catch (error) {
            throw new errors_1.ResourceError(`Failed to clear cache: ${error instanceof Error ? error.message : 'Unknown error'}`, { error: String(error) });
        }
    }
    async appendLog(logFile, entry) {
        try {
            const fullPath = path_1.default.resolve(this.baseDir, 'logs', logFile);
            if (this.createDirs) {
                await this.ensureDirectoryExists(path_1.default.dirname(fullPath));
            }
            const timestamp = new Date().toISOString();
            const logEntry = `[${timestamp}] ${entry}\n`;
            await fs_1.promises.appendFile(fullPath, logEntry, 'utf8');
        }
        catch (error) {
            throw new errors_1.ResourceError(`Failed to append log: ${error instanceof Error ? error.message : 'Unknown error'}`, { logFile, error: String(error) });
        }
    }
    async ensureDirectoryExists(dirPath) {
        try {
            await fs_1.promises.mkdir(dirPath, { recursive: true });
        }
        catch (error) {
            throw new errors_1.ResourceError(`Failed to create directory: ${error instanceof Error ? error.message : 'Unknown error'}`, { dirPath, error: String(error) });
        }
    }
    sanitizeKey(key) {
        return key.replace(/[^a-zA-Z0-9-_]/g, '_');
    }
    getFullPath(filePath) {
        return path_1.default.resolve(this.baseDir, filePath);
    }
}
exports.FileStorage = FileStorage;
//# sourceMappingURL=FileStorage.js.map