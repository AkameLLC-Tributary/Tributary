"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TributaryCLI = void 0;
const commander_1 = require("commander");
const web3_js_1 = require("@solana/web3.js");
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const ProgressBar = __importStar(require("cli-progress"));
const inquirer_1 = __importDefault(require("inquirer"));
const packageJson = __importStar(require("../../../package.json"));
const config_1 = require("../../config");
const ConfigManager_1 = require("../../infrastructure/config/ConfigManager");
const WalletCollectorService_1 = require("../../application/services/WalletCollectorService");
const DistributionService_1 = require("../../application/services/DistributionService");
const storage_1 = require("../../infrastructure/storage");
const Logger_1 = require("../../infrastructure/logging/Logger");
const parameters_1 = require("../../config/parameters");
const errors_1 = require("../../domain/errors");
class TributaryCLI {
    program;
    configManager;
    storage;
    logger = (0, Logger_1.createLogger)('TributaryCLI');
    cliOptions = {};
    constructor() {
        this.program = new commander_1.Command();
        this.configManager = new config_1.ConfigManager();
        this.storage = new storage_1.FileStorage();
        this.setupCommands();
    }
    setupCommands() {
        const params = (0, parameters_1.getParameters)();
        this.program
            .name('tributary')
            .description('Solana token distribution system')
            .version(packageJson.version)
            .option('--config <path>', 'Configuration file path', './tributary.toml')
            .option('--output <format>', 'Output format (table/json/yaml)', 'table')
            .option('--log-level <level>', 'Log level (debug/info/warn/error)', params.logging.defaultLevel)
            .option('--network <network>', 'Network override (devnet/testnet/mainnet-beta)')
            .option('--rpc-url <url>', 'RPC endpoint URL override')
            .hook('preAction', (thisCommand) => {
            const globalOpts = thisCommand.parent?.opts() || this.program.opts();
            const rootOpts = this.program.opts();
            this.configManager.setConfigPath(globalOpts.config);
            this.cliOptions = {
                network: globalOpts.network,
                rpcUrl: globalOpts.rpcUrl,
                logLevel: globalOpts.logLevel,
                outputFormat: globalOpts.output
            };
        });
        this.setupInitCommand();
        this.setupCollectCommand();
        this.setupDistributeCommand();
        this.setupConfigCommand();
        this.setupParametersCommand();
    }
    setupInitCommand() {
        this.program
            .command('init')
            .description('Initialize project configuration')
            .requiredOption('--name <name>', 'Project name (1-100 characters)')
            .requiredOption('--token <address>', 'Base token address (Solana Base58 format)')
            .requiredOption('--admin <address>', 'Admin wallet address')
            .option('-f, --force', 'Overwrite existing configuration')
            .option('--interactive, -i', 'Interactive mode')
            .option('--devnet-rpc <url>', 'Custom devnet RPC endpoint URL')
            .option('--testnet-rpc <url>', 'Custom testnet RPC endpoint URL')
            .option('--mainnet-rpc <url>', 'Custom mainnet RPC endpoint URL')
            .option('--batch-size <number>', 'Override default batch size', parseInt)
            .option('--network-timeout <ms>', 'Override network timeout (ms)', parseInt)
            .option('--max-retries <number>', 'Override max retries', parseInt)
            .option('--disable-encryption', 'Disable key encryption')
            .option('--disable-backup', 'Disable backup')
            .option('--disable-audit', 'Disable audit logging')
            .action(async (options) => {
            try {
                if (options.interactive) {
                    await this.handleInteractiveInit(options);
                }
                await this.handleInit(options);
            }
            catch (error) {
                this.handleError(error, errors_1.ErrorCodes.CONFIGURATION_ERROR);
            }
        });
    }
    setupCollectCommand() {
        this.program
            .command('collect')
            .description('Collect token holders')
            .option('--token <address>', 'Token address to collect holders for')
            .option('--threshold <amount>', 'Minimum balance threshold', '0')
            .option('--max-holders <number>', 'Maximum number of holders to collect')
            .option('--output-file <path>', 'Output file path')
            .option('--cache [value]', 'Use cache (default: true)', 'true')
            .option('--cache-ttl <seconds>', 'Cache TTL in seconds', '3600')
            .option('--exclude <addresses>', 'Exclude addresses (comma-separated)')
            .action(async (options) => {
            try {
                await this.handleCollect(options);
            }
            catch (error) {
                this.handleError(error, errors_1.ErrorCodes.GENERAL_ERROR);
            }
        });
    }
    setupDistributeCommand() {
        const distributeCmd = this.program
            .command('distribute')
            .description('Token distribution operations');
        distributeCmd
            .command('execute')
            .description('Execute token distribution')
            .requiredOption('--amount <amount>', 'Total distribution amount')
            .option('--token <address>', 'Distribution token address')
            .option('--dry-run', 'Dry run execution')
            .option('--batch-size <number>', 'Batch size', (0, parameters_1.getParameters)().distribution.defaultBatchSize.toString())
            .option('-y, --confirm', 'Skip confirmation prompt')
            .option('--wallet-file <path>', 'Private key file path')
            .action(async (options) => {
            try {
                await this.handleDistributeExecute(options);
            }
            catch (error) {
                this.handleError(error, errors_1.ErrorCodes.GENERAL_ERROR);
            }
        });
        distributeCmd
            .command('simulate')
            .description('Simulate token distribution')
            .option('--amount <amount>', 'Distribution amount')
            .option('--token <address>', 'Token address')
            .option('--mode <mode>', 'Distribution mode (equal|proportional)', 'proportional')
            .option('--minimum-amount <amount>', 'Minimum balance requirement', '0')
            .option('--batch-size <number>', 'Batch size for simulation', (0, parameters_1.getParameters)().distribution.defaultBatchSize.toString())
            .option('--detail', 'Show detailed results')
            .action(async (options) => {
            try {
                await this.handleDistributeSimulate(options);
            }
            catch (error) {
                this.handleError(error, errors_1.ErrorCodes.GENERAL_ERROR);
            }
        });
        distributeCmd
            .command('history')
            .description('Show distribution history')
            .option('--limit <number>', 'Limit results', '50')
            .option('--from <date>', 'Start date (YYYY-MM-DD)')
            .option('--to <date>', 'End date (YYYY-MM-DD)')
            .option('--format <format>', 'Output format (table/json/csv)', 'table')
            .action(async (options) => {
            try {
                await this.handleDistributeHistory(options);
            }
            catch (error) {
                this.handleError(error, errors_1.ErrorCodes.GENERAL_ERROR);
            }
        });
    }
    setupConfigCommand() {
        const configCmd = this.program
            .command('config')
            .description('Configuration management');
        configCmd
            .command('show')
            .description('Show current configuration')
            .option('--section <section>', 'Show specific section')
            .option('--format <format>', 'Output format (table/json/yaml)', 'table')
            .option('--show-secrets', 'Show sensitive information')
            .action(async (options) => {
            try {
                await this.handleConfigShow(options);
            }
            catch (error) {
                this.handleError(error, errors_1.ErrorCodes.CONFIGURATION_ERROR);
            }
        });
        configCmd
            .command('validate')
            .description('Validate configuration')
            .option('--strict', 'Strict validation mode')
            .option('--check-network', 'Check network connectivity')
            .action(async (options) => {
            try {
                await this.handleConfigValidate(options);
            }
            catch (error) {
                this.handleError(error, errors_1.ErrorCodes.VALIDATION_ERROR);
            }
        });
        configCmd
            .command('export')
            .description('Export configuration')
            .option('--output <path>', 'Output file path')
            .option('--format <format>', 'Export format (toml/json/yaml)', 'toml')
            .option('--exclude-secrets', 'Exclude sensitive information')
            .action(async (options) => {
            try {
                await this.handleConfigExport(options);
            }
            catch (error) {
                this.handleError(error, errors_1.ErrorCodes.GENERAL_ERROR);
            }
        });
    }
    async handleInteractiveInit(options) {
        const answers = await inquirer_1.default.prompt([
            {
                type: 'input',
                name: 'name',
                message: 'Project name:',
                validate: (input) => input.length >= 1 && input.length <= 100
            },
            {
                type: 'input',
                name: 'token',
                message: 'Base token address:',
                validate: this.validateSolanaAddress
            },
            {
                type: 'input',
                name: 'admin',
                message: 'Admin wallet address:',
                validate: this.validateSolanaAddress
            },
            {
                type: 'list',
                name: 'network',
                message: 'Select network:',
                choices: ['devnet', 'testnet', 'mainnet-beta']
            },
            {
                type: 'confirm',
                name: 'configureCustomRpc',
                message: 'Do you want to configure custom RPC endpoints?',
                default: false
            }
        ]);
        if (answers.configureCustomRpc) {
            const rpcAnswers = await inquirer_1.default.prompt([
                {
                    type: 'input',
                    name: 'devnetRpc',
                    message: 'Custom devnet RPC URL (leave empty for default):',
                    validate: (input) => !input || this.validateUrl(input)
                },
                {
                    type: 'input',
                    name: 'testnetRpc',
                    message: 'Custom testnet RPC URL (leave empty for default):',
                    validate: (input) => !input || this.validateUrl(input)
                },
                {
                    type: 'input',
                    name: 'mainnetRpc',
                    message: 'Custom mainnet RPC URL (leave empty for default):',
                    validate: (input) => !input || this.validateUrl(input)
                }
            ]);
            Object.assign(answers, rpcAnswers);
        }
        if (answers.network) {
            this.program.setOptionValue('network', answers.network);
        }
        Object.assign(options, answers);
    }
    async handleInit(options) {
        this.logger.info('Initializing Tributary project');
        const globalOpts = this.program.opts();
        this.validateRequiredOptions(options, ['name', 'token', 'admin']);
        this.validateInitOptions(options, globalOpts);
        const params = (0, parameters_1.getParameters)();
        const network = (globalOpts.network || params.network.defaultNetwork);
        const customRpcUrls = {};
        if (options.devnetRpc)
            customRpcUrls.devnet = options.devnetRpc;
        if (options.testnetRpc)
            customRpcUrls.testnet = options.testnetRpc;
        if (options.mainnetRpc)
            customRpcUrls['mainnet-beta'] = options.mainnetRpc;
        const overrides = {};
        if (options.batchSize !== undefined) {
            overrides.distribution = { batch_size: options.batchSize };
        }
        const networkOverrides = {};
        if (options.networkTimeout !== undefined) {
            networkOverrides.timeout = options.networkTimeout;
        }
        if (options.maxRetries !== undefined) {
            networkOverrides.max_retries = options.maxRetries;
        }
        if (Object.keys(networkOverrides).length > 0) {
            overrides.network = networkOverrides;
        }
        const securityOverrides = {};
        if (options.disableEncryption) {
            securityOverrides.key_encryption = false;
        }
        if (options.disableBackup) {
            securityOverrides.backup_enabled = false;
        }
        if (options.disableAudit) {
            securityOverrides.audit_log = false;
        }
        if (Object.keys(securityOverrides).length > 0) {
            overrides.security = securityOverrides;
        }
        if (this.cliOptions?.logLevel) {
            overrides.logging = { level: this.cliOptions.logLevel };
        }
        const config = await this.configManager.initializeProject({
            name: options.name,
            baseToken: options.token,
            adminWallet: options.admin,
            network: network,
            force: options.force,
            customRpcUrls: Object.keys(customRpcUrls).length > 0 ? customRpcUrls : undefined,
            overrides: Object.keys(overrides).length > 0 ? overrides : undefined
        });
        console.log(chalk_1.default.green('✅ Project initialized successfully'));
        console.log(chalk_1.default.blue('📁 Project name:'), config.project.name);
        console.log(chalk_1.default.blue('🌐 Network:'), config.project.network);
        console.log(chalk_1.default.blue('🪙 Base token:'), config.token.base_token);
        console.log(chalk_1.default.blue('👤 Admin wallet:'), config.token.admin_wallet);
        console.log(chalk_1.default.blue('📄 Config saved to:'), this.configManager.getConfigPath());
    }
    async handleCollect(options) {
        await this.loadConfig();
        const config = this.configManager.getProjectConfig();
        const globalOpts = this.program.opts();
        const network = (globalOpts.network || config.network);
        const tokenAddress = options.token
            ? new web3_js_1.PublicKey(options.token)
            : config.baseToken;
        const collectorService = new WalletCollectorService_1.WalletCollectorService(network);
        const collectOptions = {
            tokenAddress,
            threshold: options.threshold ? parseFloat(options.threshold) : 0,
            maxHolders: options.maxHolders ? parseInt(options.maxHolders) : undefined,
            useCache: options.cache === true || options.cache === 'true',
            cacheTtl: options.cacheTtl ? parseInt(options.cacheTtl) : 3600,
            excludeAddresses: options.exclude
                ? options.exclude.split(',').map((addr) => new web3_js_1.PublicKey(addr.trim()))
                : undefined
        };
        console.log(chalk_1.default.blue('🔍 Collecting token holders...'));
        console.log(`Token: ${tokenAddress.toString()}`);
        console.log(`Network: ${network}`);
        console.log(`Threshold: ${collectOptions.threshold} tokens`);
        const progressBar = new ProgressBar.SingleBar({
            format: chalk_1.default.cyan('Progress') + ' |{bar}| {percentage}% | {value}/{total} holders | Rate: {rate} holders/sec',
            barCompleteChar: '█',
            barIncompleteChar: '░',
            hideCursor: true
        });
        const holders = await collectorService.collectWallets(collectOptions, (progress) => {
            if (!progressBar.getTotal()) {
                progressBar.start(progress.total, progress.current, { rate: progress.rate.toFixed(1) });
            }
            progressBar.update(progress.current, { rate: progress.rate.toFixed(1) });
        });
        progressBar.stop();
        console.log(chalk_1.default.green('✅ Collection completed'));
        console.log(chalk_1.default.blue('👥 Total holders found:'), holders.length);
        if (options.outputFile) {
            let format = 'json';
            if (options.outputFile.endsWith('.csv')) {
                format = 'csv';
            }
            else if (options.outputFile.endsWith('.yaml') || options.outputFile.endsWith('.yml')) {
                format = 'yaml';
            }
            const outputPath = await collectorService.exportWallets(holders, format, options.outputFile);
            console.log(chalk_1.default.blue('💾 Saved to:'), outputPath);
        }
        this.displayTokenHolders(holders, this.getOutputFormat(options));
    }
    async handleDistributeExecute(options) {
        await this.loadConfig();
        const config = this.configManager.getProjectConfig();
        const globalOpts = this.program.opts();
        const network = (globalOpts.network || config.network);
        const amount = parseFloat(options.amount);
        if (amount <= 0) {
            throw new errors_1.ValidationError('Amount must be positive');
        }
        const tokenAddress = options.token
            ? new web3_js_1.PublicKey(options.token)
            : config.baseToken;
        const holders = await this.loadTokenHolders();
        if (holders.length === 0) {
            throw new errors_1.ValidationError('No token holders found. Run collect command first.');
        }
        const adminKeypair = await this.loadAdminKeypair(options.walletFile);
        const distributionRequest = {
            amount,
            tokenAddress,
            holders,
            batchSize: options.batchSize ? parseInt(options.batchSize) : 10
        };
        const distributionService = new DistributionService_1.DistributionService(network, adminKeypair);
        if (options.dryRun) {
            console.log(chalk_1.default.yellow('🧪 Running dry run simulation...'));
            const simulation = await distributionService.simulateDistribution(distributionRequest);
            this.displaySimulationResult(simulation, true);
            return;
        }
        const validation = await distributionService.validateDistribution(distributionRequest);
        if (!validation.isValid) {
            console.log(chalk_1.default.red('❌ Distribution validation failed:'));
            validation.errors.forEach(error => console.log(chalk_1.default.red(`  • ${error}`)));
            process.exit(errors_1.ErrorCodes.VALIDATION_ERROR);
        }
        if (validation.warnings.length > 0) {
            console.log(chalk_1.default.yellow('⚠️  Warnings:'));
            validation.warnings.forEach(warning => console.log(chalk_1.default.yellow(`  • ${warning}`)));
        }
        if (!options.confirm) {
            const { confirmed } = await inquirer_1.default.prompt([{
                    type: 'confirm',
                    name: 'confirmed',
                    message: `Distribute ${amount} tokens to ${holders.length} recipients?`,
                    default: false
                }]);
            if (!confirmed) {
                console.log(chalk_1.default.yellow('Distribution cancelled'));
                return;
            }
        }
        console.log(chalk_1.default.blue('🚀 Starting token distribution...'));
        const progressBar = new ProgressBar.SingleBar({
            format: chalk_1.default.cyan('Progress') + ' |{bar}| {percentage}% | {successful}/{total} | Rate: {rate} tx/sec',
            barCompleteChar: '█',
            barIncompleteChar: '░',
            hideCursor: true
        });
        const distribution = await distributionService.executeDistribution(distributionRequest, (progress) => {
            if (!progressBar.getTotal()) {
                progressBar.start(progress.total, progress.completed, {
                    successful: progress.successful,
                    rate: progress.rate.toFixed(1)
                });
            }
            progressBar.update(progress.completed, {
                successful: progress.successful,
                rate: progress.rate.toFixed(1)
            });
        });
        progressBar.stop();
        console.log(chalk_1.default.green('✅ Distribution completed'));
        console.log(chalk_1.default.blue('📊 Results:'));
        console.log(`  • Successful: ${distribution.getSuccessfulCount()}`);
        console.log(`  • Failed: ${distribution.getFailedCount()}`);
        console.log(`  • Total amount distributed: ${distribution.getTotalAmount()}`);
    }
    async handleDistributeSimulate(options) {
        await this.loadConfig();
        const config = this.configManager.getProjectConfig();
        const globalOpts = this.program.opts();
        const network = (globalOpts.network || config.network);
        const amount = options.amount ? parseFloat(options.amount) : 1000;
        const tokenAddress = options.token
            ? new web3_js_1.PublicKey(options.token)
            : config.baseToken;
        const holders = await this.loadTokenHolders();
        if (holders.length === 0) {
            throw new errors_1.ValidationError('No token holders found. Run collect command first.');
        }
        const mode = options.mode;
        if (mode && !['equal', 'proportional'].includes(mode)) {
            throw new errors_1.ValidationError('Distribution mode must be either "equal" or "proportional"');
        }
        const distributionRequest = {
            amount,
            tokenAddress,
            holders,
            mode: mode || 'proportional',
            minimumAmount: options.minimumAmount ? parseFloat(options.minimumAmount) : 0,
            batchSize: options.batchSize ? parseInt(options.batchSize) : 10
        };
        const adminKeypair = web3_js_1.Keypair.generate();
        const distributionService = new DistributionService_1.DistributionService(network, adminKeypair);
        const simulation = await distributionService.simulateDistribution(distributionRequest);
        this.displaySimulationResult(simulation, options.detail);
    }
    async handleDistributeHistory(options) {
        const distributionService = new DistributionService_1.DistributionService('devnet', web3_js_1.Keypair.generate());
        const history = await distributionService.getDistributionHistory();
        const filteredHistory = history.slice(0, parseInt(options.limit));
        this.displayDistributionHistory(filteredHistory, options.format);
    }
    async handleConfigShow(options) {
        await this.loadConfig();
        const config = this.configManager.getConfig();
        console.log(chalk_1.default.blue('📋 Project Configuration'));
        console.log();
        if (options.section) {
            const section = config[options.section];
            if (section) {
                console.log(JSON.stringify(section, null, 2));
            }
            else {
                throw new errors_1.ValidationError(`Section '${options.section}' not found`);
            }
        }
        else {
            this.displayConfig(config, options.format, options.showSecrets);
        }
    }
    async handleConfigValidate(_options) {
        const validation = await this.configManager.validateConfig();
        if (validation.isValid) {
            console.log(chalk_1.default.green('✅ Configuration is valid'));
        }
        else {
            console.log(chalk_1.default.red('❌ Configuration validation failed:'));
            validation.errors.forEach(error => console.log(chalk_1.default.red(`  • ${error}`)));
        }
        if (validation.warnings.length > 0) {
            console.log(chalk_1.default.yellow('⚠️  Warnings:'));
            validation.warnings.forEach(warning => console.log(chalk_1.default.yellow(`  • ${warning}`)));
        }
        process.exit(validation.isValid ? errors_1.ErrorCodes.SUCCESS : errors_1.ErrorCodes.VALIDATION_ERROR);
    }
    async handleConfigExport(options) {
        await this.loadConfig();
        const config = this.configManager.getConfig();
        const outputPath = options.output || `config.${options.format}`;
        const outputDir = path_1.default.dirname(outputPath);
        await fs_1.promises.mkdir(outputDir, { recursive: true });
        const exportConfig = options.excludeSecrets ? this.maskSecrets(config) : config;
        if (options.format === 'json') {
            await fs_1.promises.writeFile(outputPath, JSON.stringify(exportConfig, null, 2));
        }
        else if (options.format === 'yaml') {
            await fs_1.promises.writeFile(outputPath, JSON.stringify(exportConfig, null, 2));
        }
        else if (options.format === 'toml') {
            const configManager = new ConfigManager_1.ConfigManager();
            const tomlContent = configManager.stringifyToml(exportConfig);
            await fs_1.promises.writeFile(outputPath, tomlContent);
        }
        else {
            await fs_1.promises.writeFile(outputPath, JSON.stringify(exportConfig, null, 2));
        }
        console.log(chalk_1.default.green('✅ Configuration exported to'), outputPath);
    }
    async loadConfig() {
        try {
            await this.configManager.loadConfig();
        }
        catch (error) {
            if (error instanceof errors_1.ConfigurationError) {
                console.log(chalk_1.default.red('❌ Configuration not found. Run "tributary init" first.'));
                process.exit(errors_1.ErrorCodes.CONFIGURATION_ERROR);
            }
            throw error;
        }
    }
    async loadTokenHolders() {
        try {
            return await this.storage.readJson('wallets.json');
        }
        catch {
            return [];
        }
    }
    async loadAdminKeypair(walletFile) {
        if (walletFile) {
            const keyData = await fs_1.promises.readFile(walletFile, 'utf-8');
            const secretKey = JSON.parse(keyData);
            return web3_js_1.Keypair.fromSecretKey(new Uint8Array(secretKey));
        }
        throw new errors_1.ValidationError('Admin wallet keypair is required. Use --wallet-file option.');
    }
    validateSolanaAddress(address) {
        try {
            new web3_js_1.PublicKey(address);
            return true;
        }
        catch {
            return false;
        }
    }
    validateUrl(url) {
        try {
            new URL(url);
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                return 'URL must start with http:// or https://';
            }
            return true;
        }
        catch {
            return 'Invalid URL format';
        }
    }
    validateRequiredOptions(options, required) {
        for (const field of required) {
            if (!options[field]) {
                throw new errors_1.ValidationError(`${field} is required`);
            }
        }
    }
    validateInitOptions(options, globalOpts) {
        if (!options.name || typeof options.name !== 'string' || options.name.trim() === '') {
            throw new errors_1.ValidationError('Project name must be a non-empty string (1-100 characters)');
        }
        if (options.name.length > 100) {
            throw new errors_1.ValidationError('Project name must be 100 characters or less');
        }
        if (!this.validateSolanaAddress(options.token)) {
            throw new errors_1.ValidationError(`Invalid base token address: ${options.token}. Must be a valid Solana Base58 address.`);
        }
        if (!this.validateSolanaAddress(options.admin)) {
            throw new errors_1.ValidationError(`Invalid admin wallet address: ${options.admin}. Must be a valid Solana Base58 address.`);
        }
        const params = (0, parameters_1.getParameters)();
        const network = globalOpts.network || params.network.defaultNetwork;
        const validNetworks = ['devnet', 'testnet', 'mainnet-beta'];
        if (!validNetworks.includes(network)) {
            throw new errors_1.ValidationError(`Invalid network: ${network}. Must be one of: ${validNetworks.join(', ')}`);
        }
        if (options.batchSize !== undefined) {
            const batchSize = parseInt(options.batchSize);
            if (isNaN(batchSize) || batchSize < 1 || batchSize > 100) {
                throw new errors_1.ValidationError('Batch size must be a number between 1 and 100');
            }
        }
        if (options.networkTimeout !== undefined) {
            const timeout = parseInt(options.networkTimeout);
            if (isNaN(timeout) || timeout < 1000 || timeout > 300000) {
                throw new errors_1.ValidationError('Network timeout must be between 1000ms and 300000ms (5 minutes)');
            }
        }
        if (options.maxRetries !== undefined) {
            const retries = parseInt(options.maxRetries);
            if (isNaN(retries) || retries < 1 || retries > 10) {
                throw new errors_1.ValidationError('Max retries must be between 1 and 10');
            }
        }
        if (options.logLevel && !['debug', 'info', 'warn', 'error'].includes(options.logLevel)) {
            throw new errors_1.ValidationError('Log level must be one of: debug, info, warn, error');
        }
        if (options.devnetRpc && !this.validateUrl(options.devnetRpc)) {
            throw new errors_1.ValidationError(`Invalid devnet RPC URL: ${options.devnetRpc}`);
        }
        if (options.testnetRpc && !this.validateUrl(options.testnetRpc)) {
            throw new errors_1.ValidationError(`Invalid testnet RPC URL: ${options.testnetRpc}`);
        }
        if (options.mainnetRpc && !this.validateUrl(options.mainnetRpc)) {
            throw new errors_1.ValidationError(`Invalid mainnet RPC URL: ${options.mainnetRpc}`);
        }
    }
    getOutputFormat(options) {
        const globalOpts = this.program.opts();
        return options.format || globalOpts.output || 'table';
    }
    displayTokenHolders(holders, format) {
        if (format === 'json') {
            console.log(JSON.stringify(holders, null, 2));
        }
        else if (format === 'yaml') {
            console.log('holders:');
            holders.slice(0, 10).forEach((h, i) => {
                console.log(`  - address: ${h.address.toString()}`);
                console.log(`    balance: ${h.balance.toFixed(4)}`);
                console.log(`    percentage: ${h.percentage.toFixed(2)}`);
                if (i < 9 && i < holders.length - 1)
                    console.log();
            });
            if (holders.length > 10) {
                console.log(`# ... and ${holders.length - 10} more`);
            }
        }
        else {
            console.log();
            console.table(holders.slice(0, 10).map(h => ({
                Address: h.address.toString().substring(0, 12) + '...',
                Balance: h.balance.toFixed(4),
                Percentage: h.percentage.toFixed(2) + '%'
            })));
            if (holders.length > 10) {
                console.log(`... and ${holders.length - 10} more`);
            }
        }
    }
    displaySimulationResult(simulation, showDetail) {
        console.log(chalk_1.default.blue('📊 Distribution Simulation Results'));
        console.log();
        console.log(`Total amount: ${simulation.distributionBreakdown.totalAmount}`);
        console.log(`Recipients: ${simulation.distributionBreakdown.recipientCount}`);
        console.log(`Average amount: ${simulation.distributionBreakdown.averageAmount.toFixed(4)}`);
        console.log(`Estimated gas cost: ${simulation.estimatedGasCost.toFixed(6)} SOL`);
        console.log(`Estimated duration: ${(simulation.estimatedDuration / 1000).toFixed(1)}s`);
        if (showDetail) {
            console.log();
            console.log(chalk_1.default.blue('📋 Detailed Breakdown:'));
            console.log(`  • Total recipients: ${simulation.distributionBreakdown.recipientCount}`);
            console.log(`  • Minimum amount per recipient: ${simulation.distributionBreakdown.minAmount?.toFixed(6) || 'N/A'}`);
            console.log(`  • Maximum amount per recipient: ${simulation.distributionBreakdown.maxAmount?.toFixed(6) || 'N/A'}`);
            console.log(`  • Gas cost per transaction: ${(simulation.estimatedGasCost / simulation.distributionBreakdown.recipientCount).toFixed(8)} SOL`);
            console.log(`  • Estimated total transactions: ${simulation.distributionBreakdown.recipientCount}`);
            console.log(`  • Processing batch size: ${simulation.batchSize || 10}`);
            console.log(`  • Estimated batches: ${Math.ceil(simulation.distributionBreakdown.recipientCount / (simulation.batchSize || 10))}`);
            console.log(`  • Network: ${simulation.network || 'testnet'}`);
            console.log(`  • Token decimals: ${simulation.tokenDecimals || 'Unknown'}`);
        }
        if (simulation.riskFactors.length > 0) {
            console.log();
            console.log(chalk_1.default.yellow('⚠️  Risk factors:'));
            simulation.riskFactors.forEach((risk) => console.log(chalk_1.default.yellow(`  • ${risk}`)));
        }
        if (showDetail) {
            console.log();
            console.log(chalk_1.default.blue('💡 Recommendations:'));
            console.log('  • Test on devnet before mainnet execution');
            console.log('  • Verify recipient addresses carefully');
            console.log('  • Ensure sufficient balance for gas fees');
            console.log('  • Consider using smaller batch sizes for large distributions');
        }
    }
    displayDistributionHistory(history, format) {
        if (format === 'json') {
            console.log(JSON.stringify(history, null, 2));
        }
        else {
            console.table(history.map(h => ({
                ID: h.id.substring(0, 12) + '...',
                Date: new Date(h.createdAt).toLocaleDateString(),
                Recipients: h.request.holders.length,
                Amount: h.request.amount,
                Status: h.isCompleted() ? 'Completed' : 'Partial'
            })));
        }
    }
    displayConfig(config, format, showSecrets) {
        const displayConfig = showSecrets ? config : this.maskSecrets(config);
        if (format === 'json') {
            console.log(JSON.stringify(displayConfig, null, 2));
        }
        else {
            console.log(chalk_1.default.blue('📁 Project Information:'));
            console.log(`  Name: ${config.project.name}`);
            console.log(`  Network: ${config.project.network}`);
            console.log();
            console.log(chalk_1.default.blue('🪙 Token Configuration:'));
            console.log(`  Base token: ${config.token.base_token}`);
            console.log(`  Admin wallet: ${config.token.admin_wallet}`);
        }
    }
    maskSecrets(config) {
        const masked = JSON.parse(JSON.stringify(config));
        if (masked.token?.admin_wallet) {
            masked.token.admin_wallet = this.maskAddress(masked.token.admin_wallet);
        }
        return masked;
    }
    maskAddress(address) {
        return address.substring(0, 6) + '...' + address.substring(address.length - 6);
    }
    handleError(error, defaultExitCode = errors_1.ErrorCodes.GENERAL_ERROR) {
        if (error instanceof errors_1.TributaryError) {
            console.error(chalk_1.default.red(`❌ ${error.name}: ${error.message}`));
            process.exit(error.code);
        }
        else if (error instanceof Error) {
            console.error(chalk_1.default.red(`❌ Error: ${error.message}`));
            process.exit(defaultExitCode);
        }
        else {
            console.error(chalk_1.default.red(`❌ Unknown error: ${String(error)}`));
            process.exit(defaultExitCode);
        }
    }
    async run(argv) {
        try {
            await this.program.parseAsync(argv);
        }
        catch (error) {
            this.handleError(error);
        }
    }
    setupParametersCommand() {
        this.program
            .command('parameters')
            .alias('params')
            .description('Manage parameter configuration')
            .addCommand(this.program
            .createCommand('init')
            .description('Initialize parameter configuration file')
            .option('-f, --force', 'Overwrite existing configuration file')
            .action(async (options) => {
            try {
                await this.handleParametersInit(options);
            }
            catch (error) {
                console.error(chalk_1.default.red('❌ Failed to initialize parameters:'), error instanceof Error ? error.message : String(error));
                process.exit(1);
            }
        }))
            .addCommand(this.program
            .createCommand('show')
            .description('Show current parameter configuration')
            .option('--verbose', 'Show detailed configuration')
            .action(async (options) => {
            try {
                await this.handleParametersShow(options);
            }
            catch (error) {
                console.error(chalk_1.default.red('❌ Failed to show parameters:'), error instanceof Error ? error.message : String(error));
                process.exit(1);
            }
        }))
            .addCommand(this.program
            .createCommand('validate')
            .description('Validate parameter configuration')
            .action(async () => {
            try {
                await this.handleParametersValidate();
            }
            catch (error) {
                console.error(chalk_1.default.red('❌ Failed to validate parameters:'), error instanceof Error ? error.message : String(error));
                process.exit(1);
            }
        }));
    }
    async handleParametersInit(options) {
        const path = await Promise.resolve().then(() => __importStar(require('path')));
        const fs = await Promise.resolve().then(() => __importStar(require('fs')));
        const targetPath = './tributary-parameters.json';
        const templatePath = path.default.join(__dirname, '..', '..', 'tributary-parameters.example.json');
        try {
            await fs.promises.access(targetPath);
            if (!options.force) {
                console.log(chalk_1.default.yellow('⚠️ Parameter configuration file already exists.'));
                console.log(chalk_1.default.blue('💡 Use --force to overwrite, or edit the existing file:'));
                console.log(`   ${targetPath}`);
                return;
            }
        }
        catch {
        }
        try {
            const templateContent = await fs.promises.readFile(templatePath, 'utf-8');
            await fs.promises.writeFile(targetPath, templateContent, 'utf-8');
            console.log(chalk_1.default.green('✅ Parameter configuration file initialized!'));
            console.log(chalk_1.default.blue('📄 File location:'), targetPath);
            console.log(chalk_1.default.blue('📝 Edit the file to customize your settings'));
            console.log();
            console.log(chalk_1.default.yellow('Next steps:'));
            console.log('  1. Edit tributary-parameters.json');
            console.log('  2. Validate with: tributary parameters validate');
            console.log('  3. View current settings: tributary parameters show');
        }
        catch (error) {
            throw new Error(`Failed to copy template file: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async handleParametersShow(options) {
        const params = (0, parameters_1.getParameters)();
        console.log(chalk_1.default.blue('📋 Current Parameter Configuration'));
        console.log();
        if (options.verbose) {
            console.log(JSON.stringify(params, null, 2));
        }
        else {
            console.log(chalk_1.default.yellow('🌐 Network:'));
            console.log(`  Default Network: ${params.network.defaultNetwork}`);
            console.log(`  Timeout: ${params.network.timeout}ms`);
            console.log(`  Max Retries: ${params.network.maxRetries}`);
            console.log();
            console.log(chalk_1.default.yellow('📦 Distribution:'));
            console.log(`  Default Batch Size: ${params.distribution.defaultBatchSize}`);
            console.log(`  Max Batch Size: ${params.distribution.maxBatchSize}`);
            console.log(`  Batch Delay: ${params.distribution.batchDelayMs}ms`);
            console.log();
            console.log(chalk_1.default.yellow('📝 Logging:'));
            console.log(`  Level: ${params.logging.defaultLevel}`);
            console.log(`  Directory: ${params.logging.defaultDir}`);
            console.log(`  Console: ${params.logging.enableConsole ? 'enabled' : 'disabled'}`);
            console.log(`  File: ${params.logging.enableFile ? 'enabled' : 'disabled'}`);
            console.log();
            console.log(chalk_1.default.yellow('🔐 Security:'));
            console.log(`  Key Encryption: ${params.security.defaultKeyEncryption ? 'enabled' : 'disabled'}`);
            console.log(`  Backup: ${params.security.defaultBackupEnabled ? 'enabled' : 'disabled'}`);
            console.log(`  Audit Log: ${params.security.defaultAuditLog ? 'enabled' : 'disabled'}`);
        }
        console.log();
        console.log(chalk_1.default.blue('💡 Use --verbose for complete configuration'));
    }
    async handleParametersValidate() {
        try {
            const params = (0, parameters_1.getParameters)();
            console.log(chalk_1.default.blue('🔍 Validating Parameter Configuration'));
            console.log();
            let hasErrors = false;
            let hasWarnings = false;
            if (params.network.timeout < 1000) {
                console.log(chalk_1.default.red('❌ Network timeout too low (minimum 1000ms)'));
                hasErrors = true;
            }
            if (params.network.maxRetries < 1) {
                console.log(chalk_1.default.red('❌ Max retries must be at least 1'));
                hasErrors = true;
            }
            if (params.distribution.defaultBatchSize < 1) {
                console.log(chalk_1.default.red('❌ Default batch size must be at least 1'));
                hasErrors = true;
            }
            if (params.distribution.defaultBatchSize > params.distribution.maxBatchSize) {
                console.log(chalk_1.default.red('❌ Default batch size exceeds maximum batch size'));
                hasErrors = true;
            }
            if (params.distribution.defaultBatchSize > 50) {
                console.log(chalk_1.default.yellow('⚠️ Large default batch size may impact performance'));
                hasWarnings = true;
            }
            if (params.network.timeout > 60000) {
                console.log(chalk_1.default.yellow('⚠️ Very high network timeout may slow operations'));
                hasWarnings = true;
            }
            if (!params.security.defaultKeyEncryption) {
                console.log(chalk_1.default.yellow('⚠️ Key encryption is disabled - consider enabling for security'));
                hasWarnings = true;
            }
            if (!params.security.defaultBackupEnabled) {
                console.log(chalk_1.default.yellow('⚠️ Backup is disabled - consider enabling to prevent data loss'));
                hasWarnings = true;
            }
            if (hasErrors) {
                console.log();
                console.log(chalk_1.default.red('❌ Configuration has errors that must be fixed'));
                process.exit(1);
            }
            else if (hasWarnings) {
                console.log();
                console.log(chalk_1.default.yellow('⚠️ Configuration has warnings but is valid'));
            }
            else {
                console.log(chalk_1.default.green('✅ Parameter configuration is valid'));
            }
        }
        catch (error) {
            console.log(chalk_1.default.red('❌ Failed to load parameter configuration'));
            throw error;
        }
    }
}
exports.TributaryCLI = TributaryCLI;
//# sourceMappingURL=index.js.map